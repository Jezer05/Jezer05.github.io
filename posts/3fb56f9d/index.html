<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>离散数学 | Jezer's Blogs</title><meta name="robots" content="noindex"><meta name="author" content="Jezer,jezer05@qq.com"><meta name="copyright" content="Jezer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：命题逻辑                           第二章：一阶逻辑                           第三章：集合的基本概念和运算                           第四章：二元关系                           第五章：函数                           第六章：图的基本">
<meta property="og:type" content="article">
<meta property="og:title" content="离散数学">
<meta property="og:url" content="https://jezer.top/posts/3fb56f9d/index.html">
<meta property="og:site_name" content="Jezer&#39;s Blogs">
<meta property="og:description" content="第一章：命题逻辑                           第二章：一阶逻辑                           第三章：集合的基本概念和运算                           第四章：二元关系                           第五章：函数                           第六章：图的基本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/61cc7a302ab3f51d9119b16a.png">
<meta property="article:published_time" content="2022-01-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-27T11:09:29.591Z">
<meta property="article:author" content="Jezer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/61cc7a302ab3f51d9119b16a.png"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/62a09fb009475431296de262.jpg"><link rel="canonical" href="https://jezer.top/posts/3fb56f9d/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":100,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Jezer","link":"链接: ","source":"来源: Jezer's Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '离散数学',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-27 19:09:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/62a09fb109475431296de403.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon-life"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw icon-fanju"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw icon-youxi"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw icon-yinle1"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw icon-zhaopian"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw icon-dianying1"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw icon-shudan"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw icon-youlian"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/61cc7a302ab3f51d9119b16a.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jezer's Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon-life"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw icon-fanju"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw icon-youxi"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw icon-yinle1"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw icon-zhaopian"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw icon-dianying1"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw icon-shudan"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw icon-youlian"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">离散数学</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-01T16:00:00.000Z" title="发表于 2022-01-02 00:00:00">2022-01-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-27T11:09:29.591Z" title="更新于 2022-06-27 19:09:29">2022-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">复习整理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="离散数学"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/3fb56f9d/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class='checkbox checked green'><input type="checkbox" checked="checked"/>
            <p>第一章：命题逻辑</p>
            </div>
<div class='checkbox checked yellow'><input type="checkbox" checked="checked"/>
            <p>第二章：一阶逻辑</p>
            </div>
<div class='checkbox checked red'><input type="checkbox" checked="checked"/>
            <p>第三章：集合的基本概念和运算</p>
            </div>
<div class='checkbox checked cyan'><input type="checkbox" checked="checked"/>
            <p>第四章：二元关系</p>
            </div>
<div class='checkbox checked cyan'><input type="checkbox" checked="checked"/>
            <p>第五章：函数</p>
            </div>
<div class='checkbox blue'><input type="checkbox" />
            <p>第六章：图的基本概念</p>
            </div>
<div class='checkbox red'><input type="checkbox" />
            <p>第七章：特殊的图</p>
            </div>
<div class='checkbox cyan'><input type="checkbox" />
            <p>第八章：树</p>
            </div>
<div class="note orange icon-padding flat"><i class="note-icon fas fa-exclamation-circle"></i><p>Deadline：2022-01-03</p>
</div>
<h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><h3 id="命题符号化及联结词"><a href="#命题符号化及联结词" class="headerlink" title="命题符号化及联结词"></a>命题符号化及联结词</h3><blockquote>
<p>  具有唯一真值的陈述句称为<strong>命题</strong></p>
</blockquote>
<ol>
<li>x + y &gt; 5.(×)</li>
<li>这朵花多好看呀(×)</li>
<li>明天下午有会吗？(×)</li>
<li>请关上门！(×)</li>
<li>除地球外，其他星球上也有生命（√）</li>
</ol>
<blockquote>
<p>  不能再分解为更为简单句子的命题为<strong>简单命题</strong>或<strong>原子命题</strong></p>
</blockquote>
<p>简单命题可以用<em>p</em> , <em>q</em>  , <em>r</em>  , … , <em>p~i~</em>  , <em>q~i~</em> , <em>r~i~</em> , … 表示，称为<span class='p cyan'>命题符号化</span>.</p>
<p>对于简单命题来说，它的真值是确定的，因而又称为<span class='p cyan'>命题常项</span>或<span class='p cyan'>命题常元</span></p>
<p>真值可以变化的简单陈述句称为<span class='p cyan'>命题变项</span>或 <span class='p cyan'>命题变元</span>，也可以用<em>p</em> , <em>q</em>  , <em>r</em>  , … , <em>p~i~</em>  , <em>q~i~</em> , <em>r~i~</em> , …表示</p>
<blockquote>
<p>  由简单命题用联结词联结而成的命题称为<strong>复合命题</strong></p>
</blockquote>
<p>这些简单命题之间是通过如“或者”、“并且”、“不”、“如果……则……”、“当且仅当”等这样的关联词和标点符号复合而成。</p>
<p>联结词“或”，又是具有相容性，有时具有排斥性，可是在数理逻辑中不允许这种<span class='p cyan'>二义性</span>的存在，因而对联结词必须给出精确的定义，<span class='p cyan'>联结词符号化</span>很好的解决了这个问题</p>
<blockquote>
<p>  真值联结词（逻辑联结词）</p>
</blockquote>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>我们关心的是复合命题中命题之间的真值关系，而不关心命题的内容。</p>
</div>
<ol>
<li><p>==否定式==: 设<em>p</em>为一命题，复合命题“非<em>p</em>”(或“<em>p</em>的否定”)称为<em>p</em>的否定式，记作$\neg$ <em>p</em>。$\neg$ 为否定联结词，$\neg$ <em>p</em>为真当且仅当<em>p</em>为假</p>
<ul>
<li>关键词：不是、没有</li>
</ul>
</li>
<li><p>==合取式==: 设<em>p</em>、<em>q</em>为两命题，复合命题“<em>p</em>并且<em>q</em>”(或“<em>p</em>和<em>q</em>”)称为<em>p</em>与<em>q</em>的合取式，记作<em>p $\lor$ q</em>。$\land$ 称作合取联结词，<em>p $\land$ q</em>为真有且仅当<em>p</em>与<em>q</em>同时为真</p>
<ul>
<li>关键词：“既$\ldots$又$\ldots$”，“不仅$\ldots$而且$\ldots$”，“虽然$\ldots$但是$\ldots$”</li>
<li>用<em>p</em>表示“李平聪明”，<em>q</em>表示“李平用功”，“李平不是不聪明，而是不用功” $\Rightarrow$ <em>$\neg$ ( $\neg$ p) $\land$ $\neg$ q</em></li>
<li>“李文和李武是好朋友”此命题虽出现“和”，但它是简单命题，而不是复合命题</li>
</ul>
</li>
<li><p>==析取式==: 设<em>p</em>、<em>q</em>为两命题，复合命题“<em>p</em>或<em>q</em>”称作<em>p</em>与<em>q</em>的析取式，记作<em>p $\lor$ q</em>。$\lor$ 称作析取联结词，<em>p $\lor$ q</em>为假有且仅当<em>p</em>与<em>q</em>同时为假&lt;/p&gt;</p>
<ul>
<li>关键词：相容或</li>
<li><em>p</em>表示”王燕学过英语“，<em>q</em>表示“王燕学过法语”，“王燕学过英语和法语” $\Rightarrow$ <em>p $\lor$ q</em></li>
<li><em>p</em>表示“派小王开会”，<em>q</em>表示“派小李去开会”， “派小王或者小李去开会” $\Rightarrow$ <em>(p $\lor$ q) $\land$ $\neg$ (p $\land$ q)</em>, <em>(p $\land$ $\neg$ q) $\land$ ($\neg$ p $\land$ q)</em><details class="folding-tag" cyan open><summary> 例题 </summary>
              <div class='content'>
              <ol><li>张晓静爱唱歌或爱听音乐。$\Rightarrow$ 设 p：张晓静爱唱歌，q：张晓静爱听音乐。 $\Rightarrow$ p $\lor$ q</li><li>他昨天做了二十或三十道习题。 $\Rightarrow$  原子命题，因为“或”只表示了习题的近似数目。</li></ol>
              </div>
            </details>
</li>
</ul>
</li>
<li><p>==蕴涵式==: 设<em>p</em>、<em>q</em>为两命题，复合命题“如果<em>p</em>，则<em>q</em>”称作<em>p</em>与<em>q</em>的蕴涵式，记作<em>p $\rightarrow$ q</em>，称<em>q</em>为蕴涵式式的前件，<em>q</em>为蕴涵式的后件。$\rightarrow$ 称作蕴涵联结词，<em>p $\rightarrow$ q</em>为假当且仅当<em>p</em>为真<em>q</em>为假</p>
<ul>
<li>关键词：“只要<em>p</em>就<em>q</em>”, “<em>p</em>仅当<em>q</em>”, “因为<em>p</em>，所以<em>q</em>“, “只有<em>q</em>才<em>p</em>”, “除非<em>q</em>才<em>p</em>“, “除非<em>q</em>，否则非<em>p</em>“</li>
<li><em>q</em>是<em>p</em>的必要条件，或<em>p</em>是<em>q</em>的充分条件</li>
<li>在数理逻辑中<em>p $\rightarrow$ q</em>中的<em>p</em>与<em>q</em>不一定有什么内在联系<details class="folding-tag" cyan open><summary> 例题 </summary>
              <div class='content'>
              <ol><li>a能被4整除，仅当a能被2整除。$\Rightarrow$ 设 p: a能被4整除 q: a能被2整除 $\Rightarrow$ p $\rightarrow$ q</li></ol>
              </div>
            </details>
<details class="folding-tag" cyan open><summary> 扩展 </summary>
              <div class='content'>
              <p>作为一种规定，当p为假时，无论q是真是假，p→q均为真。也就是说，只有p为真q为假这一种情况使得复合命题p→q为假。称为<span class='p cyan'>实质蕴含</span>。</p>
              </div>
            </details>
</li>
</ul>
</li>
<li><p>==等价式==: 设<em>p</em>、<em>q</em>为两命题，复合命题“<em>p</em>当且仅当<em>q</em>”称作<em>p</em>与<em>q</em>的等价式，记作<em>p $\leftrightarrow$ q</em>。$\leftrightarrow$ 称作等价联结词，<em>p $\leftrightarrow$ q</em>为真当且仅当<em>p</em>与<em>q</em>的真值相同</p>
<ul>
<li>关键词：“当且仅当”</li>
<li><em>p</em>与<em>q</em>互为充分必要条件</li>
<li>(<em>p</em> $\rightarrow$ <em>q</em>) $\land$ (<em>q</em> $\rightarrow$ <em>p</em>) 与 <em>p</em> $\rightleftarrow$ <em>q</em> 的逻辑关系完全一致</li>
<li>在数理逻辑中<em>p $\leftrightarrow$ q</em>中的<em>p</em>与<em>q</em>不一定有什么内在联系</li>
</ul>
</li>
</ol>
<h3 id="命题公式及分类"><a href="#命题公式及分类" class="headerlink" title="命题公式及分类"></a>命题公式及分类</h3><blockquote>
<p>  命题常项和命题变项</p>
</blockquote>
<ol>
<li>简单命题是真值唯一确定的命题逻辑中最基本的研究单位，所以也称简单命题为<span class='p cyan'>命题常项</span>或<span class='p cyan'>命题常元</span>。</li>
<li>称真值可以变化的陈述句为<span class='p cyan'>命题变项</span>或<span class='p cyan'>命题变元</span>,当p,q,r,…表示命题变项时，它们就成了取值0或1的变项，因而命题变项已不是命题。</li>
</ol>
<blockquote>
<p>  命题公式</p>
</blockquote>
<p>若在复合命题中，<em>p</em> , <em>q</em>  , <em>r</em>  , … , <em>p~i~</em>  , <em>q~i~</em> , <em>r~i~</em> , …不仅可以代表命题常项，还可以代表命题变项，这样组成的复合命题形式称为<span class='p cyan'>命题公式</span>，也称<span class='p cyan'>合式公式</span>，简称<span class='p cyan'>公式</span></p>
<ol>
<li>单个命题变项 <em>p</em> , <em>q</em>  , <em>r</em>  , … , <em>p~i~</em>  , <em>q~i~</em> , <em>r~i~</em> , …是合式公式，并称为<span class='p cyan'>原子命题公式</span>。</li>
<li>如果A是合式公式，则($\neg$ A)也是合式公式。</li>
<li>如果A、B是合式公式，则(A $\land$ B)、(A $\lor$ B)、(A $\rightarrow$ B)、(A $\leftrightarrow$ B) 也是合式公式。</li>
<li>只有有限次地应用1~3组成的符号串才是合式公式。<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><ol>
<li>为方便起见，($\neg$ A)、(A $\land$ B)等的外层括号可以省去。</li>
<li>设A为合式公式，B为A中一部分，若B也是合式公式，则称B为A的<span class='p cyan'>子公式</span>。</li>
<li>给出的合式公式的定义方式称为<span class='p cyan'>归纳定义</span>或<span class='p cyan'>递归定义</span>方式。</li>
<li>定义中引进了A,B等符号，用它们表示任意的合式公式，而不是某个具体的公式。</li>
<li>A,B等符号被称作元语言符号。p,q等被称作对象语言符号。</li>
<li><span class='p cyan'>对象语言</span>是指用来描述研究对象的语言，而<span class='p cyan'>元语言</span>是指用来描述对象的语言，这两种语言是不同层次的语言。例如中国人学习英语时，英语为对象语言，而用来学习英语的汉语则是元语言。</li>
</ol>
</div>
</li>
</ol>
<blockquote>
<p>  公式的层次</p>
</blockquote>
<ol>
<li>若A是单个命题（常项或变项），则称A为0层公式</li>
<li><p>称A是n + 1（n≥0）层公式是指下列诸情况之一</p>
<p> ​1. A= $\neg$ B，B为n层公式<br> ​2. A=B $\land$ C，其中B、C分别为i层和j层公式，且n=max（i，j）<br> ​3. A=B $\lor$ C，其中B、C分别为i层和j层公式，且n=max（i，j）<br> ​4. A=B $\rightarrow$ C，其中B、C分别为i层和j层公式，且n=max（i，j）<br> ​5. A=B $\leftrightarrow$ C，其中B、C分别为i层和j层公式，且n=max（i，j）</p>
</li>
<li><p>若A的层次为k，则称A为k层公式</p>
<ul>
<li>一个含有命题变项的命题公式的真值是不确定的，只有对它的每个命题变项用指定的命题常项代替后，命题公式才变成命题，其真值也就唯一确定了</li>
</ul>
</li>
</ol>
<blockquote>
<p>  赋值（解释）</p>
</blockquote>
<ol>
<li>设A为一命题公式，<em>p~1~</em>, <em>p~2~</em> , <em>p~3~</em> , … , <em>p~n~</em> 为出现在A中的所有的命题变项，给 <em>p~1~</em>, <em>p~2~</em> , <em>p~3~</em> , … , <i>p~n~</i> 指定一组真值，称为对A的一个<span class='p cyan'>赋值或解释</span>。若指定的一组值使A的值为真，则称这组值为A的<span class='p cyan'>成真赋值</span>；若使A的值为假，则称这组值为A的<span class='p cyan'>成假赋值</span></li>
<li>含n(n $\geq$ 1)个命题变项的公式共有2^n^个不同的赋值。<blockquote>
<p>  真值表</p>
</blockquote>
</li>
</ol>
<p>设公式A含有n（n≥1）个命题变项，将A在2^n^个赋值下的取值情况列成表，称为A的<span class='p cyan'>真值表</span></p>
<p>构造真值表的具体步骤：</p>
<ol>
<li>找出命题公式中所含的所有命题变项<em>p~1~ , p~2~ , p~3~ , … , p~n~</em>（按照字典序和下标数字大小给出）</li>
<li>按从低到高的顺序写出各层次</li>
<li>列出所有可能的赋值。从00……0（n位，二进制）开始，每次加1（十进制），直到11……1为止</li>
<li>对应每个赋值，计算命题公式各层次的值，直到最后计算成命题公式的值<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>公式A与B具有相同的或不同的真值表，是指真值表的最后一列是否相同，而不考虑构造真值表的中间过程。</p>
</div>
<details class="folding-tag" cyan><summary> 示例 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">p</th><th style="text-align:center">q</th><th style="text-align:center">r</th><th style="text-align:center">$\neg$ r</th><th style="text-align:center">q $\lor$ $\neg$ r</th><th style="text-align:center">p $\land$ ( q $\lor$  $\neg$ r )</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div>
              </div>
            </details>
</li>
</ol>
<blockquote>
<p>  公式分类</p>
</blockquote>
<p>设A为一个公式</p>
<ol>
<li>若A无成假赋值，则称A为重言式或永真式</li>
<li>若A无成真赋值，则称A为矛盾式或永假式</li>
<li>若A至少有一个成真赋值，则称A为可满足式</li>
<li>若A至少有一个成真赋值，又至少有一个成假赋值，则称A为非重言式的可满足式</li>
</ol>
<blockquote>
<p>  n元真值函数</p>
</blockquote>
<p>一个n（n $\geq$ 1）阶笛卡尔积 {0,1}^n^ 到 {0,1} 的函数称为一个n元真值函数。n元真值函数F记为F：{0,1}^n^ $\rightarrow$ {0,1}</p>
<p>n个命题变项，共有2^n^个可能的赋值。对于每个赋值，真值函数的函数值非0即1。于是n个命题变元共可以形成4^n^个不同的真值函数。<span class='p cyan'>每个真值函数对应一个真值表</span>，也对应无穷多个命题公式，这些公式彼此都是等值的，它们中的每一个都是这个真值函数的一个表达形式。</p>
<details class="folding-tag" cyan><summary> 示例 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">p  q</th><th style="text-align:center">F~1~</th><th style="text-align:center">F~2~</th><th style="text-align:center">F~3~</th><th style="text-align:center">F~4~</th><th style="text-align:center">F~5~</th><th style="text-align:center">F~6~</th><th style="text-align:center">F~7~</th><th style="text-align:center">F~8~</th></tr></thead><tbody><tr><td style="text-align:center">0       0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0       1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1       0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1       1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">p      q</th><th style="text-align:center">F~9~</th><th style="text-align:center">F~10~</th><th style="text-align:center">F~11~</th><th style="text-align:center">F~12~</th><th style="text-align:center">F~13~</th><th style="text-align:center">F~14~</th><th style="text-align:center">F~15~</th><th style="text-align:center">F~16~</th></tr></thead><tbody><tr><td style="text-align:center">0       0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0       1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1       0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1       1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div>
              </div>
            </details>
<div class="note green icon-padding simple"><i class="note-icon fas fa-check-circle"></i><ol>
<li>F~1~对应的命题公式都是矛盾式，F~16~对应的命题公式都是重言式</li>
<li>n个命题变项共产生2^n^个不同赋值</li>
<li>含n个命题变项的公式的真值表只有2<sup>2<sup>n</sup>&lt;/sup&gt;种不同情况</li>
</ol>
</div>
<blockquote>
<p>  哑元</p>
</blockquote>
<p>设公式A,B中共含有命题变项<i>p~1~, p~2~, … , p~n~</i>，而A或 B不全含有这些命题变项，比如A中不含<i>p~i~, p~i+1~, … , p~n~</i> ,称这些命题变项为A的<span class='p cyan'>哑元</span>，A的取值与哑元的变化无关，因而在讨论A与B是否有相等的真值表时，将A,B都看成<i>p~1~, p~2~, … , p~n~</i>的命题公式。</p>
<details class="folding-tag" cyan><summary> 举个栗子 </summary>
              <div class='content'>
              <p>(1) p $\rightarrow$ q<br>(2) $\neg$ q $\lor$ r</p><p>r是公式(1)的哑元,P是公式(2)的哑元,讨论它们是否有相同的真值表时,均按3个命题变项写出它们的真值表</p>
              </div>
            </details>
<details class="folding-tag" red><summary> 易错集 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61ceaf422ab3f51d91a01aef.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ceaf552ab3f51d91a031e2.png" alt=""></p>
              </div>
            </details>
<h3 id="等值演算"><a href="#等值演算" class="headerlink" title="等值演算"></a>等值演算</h3><blockquote>
<p>  基本等值式</p>
</blockquote>
<p>判断A与B是否等值等价于判断A、B的真值表是否相同。</p>
<p>设A、B为两命题公式，若等价式A $\leftrightarrow$ B是重言式，则称A与B是等值的，记作A $\Leftrightarrow$ B。A或B中可能有哑元出现.</p>
<details class="folding-tag" cyan open><summary> 基本等值式 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">双重否定率</td><td style="text-align:center">$\neg$ $\neg$ A $\Leftrightarrow$  A</td></tr><tr><td style="text-align:center">等幂律</td><td style="text-align:center">A $\lor$ A $\Leftrightarrow$ A<br> A $\land$ A $\Leftrightarrow$ A</td></tr><tr><td style="text-align:center">交换律</td><td style="text-align:center">A $\lor$ B $\Leftrightarrow$ B $\lor$ A<br>A $\land$ B $\Leftrightarrow$ B $\land$ A</td></tr><tr><td style="text-align:center">结合律</td><td style="text-align:center">(A $\lor$ B) $\lor$ C $\Leftrightarrow$ A $\lor$ (B $\lor$ C)<br> (A $\land$ B) $\land$ C $\Leftrightarrow$ A $\land$ (B $\land$ C)</td></tr><tr><td style="text-align:center">分配律</td><td style="text-align:center">A $\lor$ (B $\land$ C) $\Leftrightarrow$  (A $\lor$ B) $\land$ (A $\lor$ C)<br>A $\land$ (B $\lor$ C) $\Leftrightarrow$ (A $\land$ B) $\lor$ (A $\land$ C )</td></tr><tr><td style="text-align:center">德 $\cdot$ 摩根律</td><td style="text-align:center">$\neg$ (A $\lor$ B) $\Leftrightarrow$ $\neg$ A $\land$ $\neg$ B<br>$\neg$ (A $\land$ B) $\Leftrightarrow$ $\neg$ A $\lor$ $\neg$ B</td></tr><tr><td style="text-align:center">吸收律</td><td style="text-align:center">A $\lor$ (A $\land$ B) $\Leftrightarrow$ A<br>A $\land$ (A $\lor$ B) $\Leftrightarrow$ A</td></tr><tr><td style="text-align:center">零律</td><td style="text-align:center">A $\lor$ 1 $\Leftrightarrow$ 1<br>A $\land$ 0 $\Leftrightarrow$  0</td></tr><tr><td style="text-align:center">同一律</td><td style="text-align:center">A $\lor$ 0 $\Leftrightarrow$ A<br>A $\land$ 1 $\Leftrightarrow$ A</td></tr><tr><td style="text-align:center">排中律</td><td style="text-align:center">A $\lor$ $\neg$ A $\Leftrightarrow$ 1</td></tr><tr><td style="text-align:center">矛盾律</td><td style="text-align:center">A $\land$ $\neg$ A $\Leftrightarrow$ 0</td></tr><tr><td style="text-align:center">蕴涵等值式</td><td style="text-align:center">A $\rightarrow$ B $\Leftrightarrow$ $\neg$ A $\lor$ B</td></tr><tr><td style="text-align:center">等价等值式</td><td style="text-align:center">A $\leftrightarrow$ B $\Leftrightarrow$ (A $\rightarrow$ B) $\land$ (B $\rightarrow$ A)</td></tr><tr><td style="text-align:center">假言易位</td><td style="text-align:center">A $\rightarrow$ B $\Leftrightarrow$ $\neg$ B $\rightarrow$ $\neg$ A</td></tr><tr><td style="text-align:center">等价否定等值式</td><td style="text-align:center">A $\leftrightarrow$ B $\Leftrightarrow$ $\neg$ A $\leftrightarrow$ $\neg$ B</td></tr><tr><td style="text-align:center">归谬论</td><td style="text-align:center">(A $\rightarrow$ B) $\land$ (A $\rightarrow$ $\neg$ B) $\Leftrightarrow$ $\neg$ A</td></tr></tbody></table></div>
              </div>
            </details>
<div class="note green icon-padding simple"><i class="note-icon fas fa-check-circle"></i><ol>
<li>以上等值式都不难用真值表证明</li>
<li>由于A、B、C代表的是任意的命题公式，因而每个公式都是一个模式，他可代表无数多个同类型的命题公式</li>
<li>由已知等值式推演出与给定公式等值的公式的过程为<span class='p cyan'>等值演算</span></li>
<li>对偶原理：一个逻辑<span class='p cyan'>等值式</span>，如果只含有 $\neg$、$\lor$、$\land$、0、1那么同时把$\lor和$\land$互换把0和1互换得到的还是等值式。</li>
<li>各等值式都是用元语言符号书写的，其中A,B,C可以代表任意的公式，称这样的等值式为<span class='p blue'>等值式模式</span>。</li>
<li>具体的等值式都被称为原来的等值式模式的<span class='p blue'>代入实例</span></li>
</ol>
</div>
<blockquote>
<p>  置换规则</p>
</blockquote>
<p>设 $\Phi$ (A)是含公式A的命题公式，$\Phi$ (B) 是用B置换 $\Phi$ (A) 中的A之后得到的公式，若A $\Leftrightarrow$ B，则 $\Phi$ (A) $\Leftrightarrow$ $\Phi$ (B)</p>
<blockquote>
<p>等值演算</p>
</blockquote>
<p>由已知的等值式推演出另外一些等值式的过程为等值演算</p>
<details class="folding-tag" blue><summary> 等值演算的相关说明 </summary>
              <div class='content'>
              <div class="tabs" id="等值演算"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#等值演算-1">基础</button></li><li class="tab"><button type="button" data-href="#等值演算-2">应用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="等值演算-1"><ol><li>等值关系的性质：<ul><li>自反性：A $\Leftrightarrow$ A。</li><li>对称性：若A $\Leftrightarrow$ B，则B $\Leftrightarrow$ A。</li><li>传递性：若A $\Leftrightarrow$ B 且 B $\Leftrightarrow$ C，则A $\Leftrightarrow$ C。</li></ul></li><li>基本的等值式</li><li>置换规则</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="等值演算-2"><ol><li>证明两个公式等值</li><li>判断公式类型</li><li>解判定问题</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
              </div>
            </details>
<details class="folding-tag" green><summary> 例题 </summary>
              <div class='content'>
              <div class="tabs" id="例题"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#例题-1">公式等值</button></li><li class="tab"><button type="button" data-href="#例题-2">判断公式类型</button></li><li class="tab"><button type="button" data-href="#例题-3">解判定问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="例题-1"><p><img src="https://pic.imgdb.cn/item/61ced6aa2ab3f51d91c385f0.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ced6c02ab3f51d91c39b0e.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="例题-2"><p><img src="https://pic.imgdb.cn/item/61ced7692ab3f51d91c43b35.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ced79a2ab3f51d91c46cd5.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ced7a52ab3f51d91c47a09.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="例题-3"><p>在某次研讨会的中间休息时间，3名与会者根据王教授的口音对他是哪个省市的人进行了判断：<br>甲说王教授不是苏州人，是上海人。<br>乙说王教授不是上海人，是苏州人。<br>丙说王教授既不是上海人，也不是杭州人。<br>听完以上3人的判断后，王教授笑着说，他们3人中有一人说的全对，有一人说对了一半，另一人说的全不对。试用逻辑演算法分析王教授到底是哪里人？</p><p>设命题 p：王教授是苏州人。q：王教授是上海人。 r：王教授是杭州人。p,q,r中必有一个真命题，两个假命题，要通过逻辑演算将真命题找出来。<br>甲的判断为A~1~= $\neg$ p $\land$ q<br>乙的判断为A~2~= p $\land$ $\neg$ q<br>丙的判断为A~3~= $\neg$ q $\land$ $\neg$ r<br><img src="https://pic.imgdb.cn/item/61ced94e2ab3f51d91c5b684.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ced9612ab3f51d91c5c343.png" alt=""><br>过程简化；王教授只可能是其中一个城市的人或者三个城市都不是。所以，丙至少说对了一半。因此，可得甲或乙必有一人全错了。又因为，若甲全错了，则有p∧┐q，因此乙全对。同理，乙全错则甲全对。所以丙必是一对一错。根据上述推理，可对公式E进行简化，方便等值演算。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
              </div>
            </details>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote>
<p>  简单析取式和简单合取式</p>
</blockquote>
<p>命题变项及其否定统称作<span class='p cyan'>文字</span><br>仅由有限个命题变项或其否定构成的析取式称为<span class='p cyan'>简单析取式</span><br>仅由有限个命题变项或其否定构成的合取式为<span class='p cyan'>简单合取式</span></p>
<ol>
<li>一个简单析取式是重言式，当且仅当它同时含有一个命题变项及其否定</li>
<li>一个简单合取式是矛盾式，当且仅当它同时含有一个命题变项及其否定</li>
</ol>
<p>例如，简单析取式<em>p $\lor$ $\neg$p $\lor$ q</em>是重言式</p>
<blockquote>
<p>  析取范式和合取范式</p>
</blockquote>
<p>仅由有限个简单合取式构成的析取式称为<span class='p cyan'>析取范式</span><br>仅由有限个简单析取式构成的合取式称为<span class='p cyan'>合取范式</span></p>
<ol>
<li>一个析取范式是矛盾式，当且仅当它的每个简单合取式是矛盾式</li>
<li>一个合取范式是重言式，当且仅当它的每个简单析取式是重言式</li>
</ol>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><ol>
<li>形如 $\neg$ p $\lor$ q $\lor$ r的公式既是一个简单合取式构成的析取范式，又是由三个简单析取式构成的合取范式。</li>
<li>形如 $\neg$ p $\land$ q $\land$ r的公式既是含三个简单合取式的析取范式，又是含一个简单析取式的合取范式。</li>
<li>研究范式的目的在于，将给定公式化成与之等值的析取范式或合取范式，进而将公式化成与之等值的主析取范式或主合取范式。</li>
</ol>
</div>
<blockquote>
<p>  范式存在定理</p>
</blockquote>
<p>范式存在定理：任一命题公式都存在与之等值的析取范式和合取范式，且不是唯一的</p>
<div class="note orange icon-padding simple"><i class="note-icon fas fa-exclamation-circle"></i><ol>
<li>在范式中不会出现联结词 $\rightarrow$ 与 $\leftrightarrow$ ，否则可使用等值式消除</li>
<li>在范式中不会出现形如$\neg$ $\neg$ A, $\neg$ (A $\land$ B), $\neg$(A $\lor$ B)的公式</li>
<li>在析取范式中不会出现形如A $\land$ (B $\lor$ C)的公式</li>
<li>在合取范式中不出现形A $\lor$ (B $\land$ C)的公式</li>
</ol>
</div>
<details class="folding-tag" blue><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61ceea872ab3f51d91d2ece7.png" alt=""><br><img src="https://pic.imgdb.cn/item/61ceea972ab3f51d91d2fc26.png" alt=""></p>
              </div>
            </details>
<p>由于与某一命题公式等值的析取范式与合取范式的不唯一性，因而析取范式与合取范式不能作为同一真值函数所对应的命题公式的标准形式</p>
<blockquote>
<p>  极小项</p>
</blockquote>
<p>设有n个命题变项，若在简单合取式中每个命题变项与其否定<span class='p cyan'>出现且仅出现一次</span>，则称这样的简单合取式为极小项。在极小项中，命题变项与其否定通常按下角标和字典顺序排列。<br><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>将命题变项看成1，命题变项的否定看成0，则每个极小项对应一个二进制数。这个二进制数正好是该极小项的<span class='p cyan'>成真赋值</span>。用这个二进制数对应的十进制数作为该极小项符号的角码</li>
<li>n个命题变项共可产生 2^n^ 个不同的极小项，分别记为 m~0~ ， m~1~ ， …… ， m<sub>2<sup>n</sup>-1</sub></li>
</ul>
</div></p>
<blockquote>
<p>  主析取范式</p>
</blockquote>
<p>如果公式A的析取范式中的简单合取式全是极小项，则称该析取范式为A的<span class='p cyan'>主析取范式</span></p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>任何命题公式都有<span class='p cyan'>唯一</span>的主析取范式</p>
<ul>
<li>只要知道一个命题公式A的主析取范式，即可写出真值表</li>
<li>反之，若知道了A的真值表，找出所有的成真赋值，以对应的十进制数作为角码的极小项，从而可立即写出A的主析取范式</li>
<li>由于任何命题公式的主析取范式都是唯一的，因而若A $\Leftrightarrow$ B，说明A与B有相同的主析取范式。反之，若A，B有相同的主析取范式，必有A $\Leftrightarrow$ B</li>
<li>判断命题公式的类型<ul>
<li>A为<span class='p cyan'>重言式</span>，当且仅当A的主析取范式中含全部2^n^ 个极小项</li>
<li>A为<span class='p cyan'>矛盾式</span> ，当且仅当A的主析取范式不含任何极小项，此时记A的主析取范式为0</li>
</ul>
</li>
</ul>
</div>
<details class="folding-tag" red open><summary> 举例 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">极小项</th><th style="text-align:center">二进制</th><th style="text-align:center">写法</th></tr></thead><tbody><tr><td style="text-align:center">$\neg$ p $\land$ $\neg$ q $\land$ $\neg$ r</td><td style="text-align:center">000</td><td style="text-align:center">m~0~</td></tr><tr><td style="text-align:center">$\neg$ p $\land$ $\neg$ q $\land$ r</td><td style="text-align:center">001</td><td style="text-align:center">m~1~</td></tr><tr><td style="text-align:center">$\neg$ p $\land$ q $\land$ $\neg$ r</td><td style="text-align:center">010</td><td style="text-align:center">m~2~</td></tr><tr><td style="text-align:center">$\neg$ p $\land$ q $\land$ r</td><td style="text-align:center">011</td><td style="text-align:center">m~3~</td></tr><tr><td style="text-align:center">p $\land$ $\neg$ q $\land$ $\neg$ r</td><td style="text-align:center">100</td><td style="text-align:center">m~4~</td></tr><tr><td style="text-align:center">p $\land$ $\neg$ q $\land$ r</td><td style="text-align:center">101</td><td style="text-align:center">m~5~</td></tr><tr><td style="text-align:center">p $\land$ q $\land$ $\neg$ r</td><td style="text-align:center">110</td><td style="text-align:center">m~6~</td></tr><tr><td style="text-align:center">p $\land$ q $\land$ r</td><td style="text-align:center">111</td><td style="text-align:center">m~7~</td></tr></tbody></table></div>
              </div>
            </details>
<blockquote>
<p>  极大项</p>
</blockquote>
<p>设有n个命题变项，若在简单析取式中每个命题变项与其否定<span class='p cyan'>出现且仅出现一次</span>，则称这样的简单析取式为极大项。在极大项中，命题变项与其否定通常按下角标和字典顺序排列。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>将命题变项看成0，命题变项的否定看成1，则每个极大项对应一个二进制数。这个二进制数正好是该极大项的<span class='p cyan'>成假赋值</span>。用这个二进制数对应的十进制数作为该极大项符号的角码</li>
<li>n个命题变项共可产生 2^n^ 个不同的极大项，分别记为 M~0~ ， M~1~ ， …… ， M<sub>2<sup>n</sup>-1</sub></li>
</ul>
</div>
<blockquote>
<p>  主合取范式</p>
</blockquote>
<p>如果公式A的合取范式中的简单析取式全是极大项，则称该析取范式为A的<span class='p cyan'>主合取范式</span></p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>任何命题公式都有<span class='p cyan'>唯一</span>的主析取范式</li>
<li>主析取范式和主合取范式互为对偶</li>
<li>设mi与Mi是命题变项<i>p~1~, p~2~, … , p~n~ </i> 形成的极小项和极大项，则 $\neg$ m~i~ $\Leftrightarrow$ M~i~，$\neg$ M~i~ $\Leftrightarrow$ m~i~</li>
</ul>
</div>
<details class="folding-tag" blue open><summary> 应用 </summary>
              <div class='content'>
              <ol><li>求公式的成真赋值与成假赋值</li><li>判断公式的类型</li><li>判断两个命题公式是否等值</li><li>应用主析取范式分析和解决实际问题</li></ol>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61cef5092ab3f51d91dc1b39.png" alt=""><br><img src="https://pic.imgdb.cn/item/61cef5d32ab3f51d91dcbb2a.png" alt=""><br><img src="https://pic.imgdb.cn/item/61cef5de2ab3f51d91dcc32a.png" alt=""><br><img src="https://pic.imgdb.cn/item/61cef6f92ab3f51d91dd8e92.png" alt=""></p>
              </div>
            </details>
<h3 id="联结词全功能集"><a href="#联结词全功能集" class="headerlink" title="联结词全功能集"></a>联结词全功能集</h3><blockquote>
<p>  全功能集</p>
</blockquote>
<p>一般来说，在自然推理系统中，联结词集中的联结词越少越好，但必须具备表示所有真值函数的能力。</p>
<p>设S是一个联结词集合，如果任一真值函数都可以用仅含S中的联结词的命题公式表示，则称S为<span class='p cyan'>全功能集</span></p>
<p>{ $\neg$ , $\land$ , $\lor$ }、{$\neg$ , $\land$ } 、{$\neg$ , $\land$ }、{$\neg$ , $\rightarrow$}都是联结词全功能集</p>
<blockquote>
<p>与非联结词</p>
</blockquote>
<p>设<em>p</em> 、<em>q</em> 为两命题，复合命题”<em>p</em> 与 <em>q</em> 的否定”称为<em>p</em> 与 <em>q</em>的与非式，记作 <em>p $\uparrow$ q</em> ，即 p $\uparrow$ q $\Leftrightarrow$ $\neg$ (p $\land$ q) ,  $\uparrow$ 称作<span class='p cyan'>与非联结词</span></p>
<blockquote>
<p>  或非联结词</p>
</blockquote>
<p>设<em>p</em> 、<em>q</em> 为两命题，复合命题”<em>p</em> 或 <em>q</em> 的否定”称为<em>p</em> 或 <em>q</em>的与非式，记作 <em>p $\downarrow$ q</em> ，即 p $\downarrow$ q $\Leftrightarrow$ $\neg$ (p $\lor$ q) ,  $\uparrow$ 称作<span class='p cyan'>或非联结词</span></p>
<pre><code>* &#123;$\uparrow$&#125;、&#123;$\downarrow$&#125;是联结词全功能集

* 除此之外，还有许多联结词全功能集
</code></pre><h3 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h3><p>略</p>
<h3 id="推理理论"><a href="#推理理论" class="headerlink" title="推理理论"></a>推理理论</h3><blockquote>
<p>  推理、前提、结论、证明</p>
</blockquote>
<ol>
<li><span class='p cyan'>推理</span>是从前提推出结论的思维工程</li>
<li><span class='p cyan'>前提</span>是指已知的命题公式</li>
<li><span class='p cyan'>结论</span>是指从前提出发应用推理规则推出的命题公式</li>
<li><span class='p cyan'>证明</span>是一个描述推理过程的命题公式序列，其中每个命题公式或者是已知的前提，或者是由前面的命题公式应用推理规则得到的结论</li>
</ol>
<blockquote>
<p>  推理正确、逻辑结论、推理的形式结构</p>
</blockquote>
<p>若(A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~) $\rightarrow$ B 为重言式，则称(A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~) 推出结论B的<span class='p cyan'>推理正确</span>， B是 A~1~ , A~2~ , $\cdots$ , A~k~ 的<span class='p cyan'>逻辑结论</span>或<span class='p cyan'>有效结论</span>。称(A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~) $\rightarrow$ B 为由前提 A~1~ , A~2~ , $\cdots$ , A~k~ 推出结论B的<span class='p cyan'>推理的形式结构</span></p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>用 A $\Leftrightarrow$ B 表示 A $\leftrightarrow$ B 是重言式类似，用 A $\Rightarrow$ B 表示 A $\rightarrow$ B 是重言式</li>
<li>判断推理是否正确就是判断一个蕴涵式是否为重言式（等值演算）</li>
</ul>
</div>
<blockquote>
<p>  推理定律</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">定律</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">附加</td>
<td style="text-align:center">A $\Rightarrow$ (A $\lor$ B)</td>
</tr>
<tr>
<td style="text-align:center">化简</td>
<td style="text-align:center">(A $\land$ B) $\Rightarrow$ A</td>
</tr>
<tr>
<td style="text-align:center">假言推理</td>
<td style="text-align:center">((A $\rightarrow$ B) $\land$  A) $\Rightarrow$ B</td>
</tr>
<tr>
<td style="text-align:center">拒取式</td>
<td style="text-align:center">((A $\rightarrow$ B) $\land$  $\neg$ B) $\Rightarrow$ $\neg$ A</td>
</tr>
<tr>
<td style="text-align:center">析取三段论</td>
<td style="text-align:center">((A $\lor$ B) $\land$ $\neg$ A) $\Rightarrow$ B</td>
</tr>
<tr>
<td style="text-align:center">假言三段论</td>
<td style="text-align:center">((A $\rightarrow$ B) $\land$ (B $\rightarrow$ C)) $\Rightarrow$ (A $\rightarrow$ C)</td>
</tr>
<tr>
<td style="text-align:center">等价三段论</td>
<td style="text-align:center">((A $\leftrightarrow$ B) $\land$ (B $\leftrightarrow$ C)) $\Leftrightarrow$ (A $\leftrightarrow$ C)</td>
</tr>
<tr>
<td style="text-align:center">构造性二难</td>
<td style="text-align:center">(A $\rightarrow$ B) $\land$ (C $\rightarrow$ D) $\land$ (A $\lor$ C) $\Leftrightarrow$ (B $\lor$ D)</td>
</tr>
<tr>
<td style="text-align:center">构造性二难(特殊形式)</td>
<td style="text-align:center">(A $\rightarrow$ B) $\land$ ($\neg$ A $\rightarrow$ B) $\land$ (A $\lor$ $\neg$ A) $\Leftrightarrow$ B</td>
</tr>
<tr>
<td style="text-align:center">破坏性二难</td>
<td style="text-align:center">(A $\rightarrow$ B) $\land$ (C $\rightarrow$ D) $\land$ ($\neg$ B $\lor$  $\neg$ D) $\Leftrightarrow$ ($\neg$ A $\lor$  $\neg$ C)</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>  推理规则</p>
</blockquote>
<p>在以下推理规则中，用 A~1~ , A~2~ , … , A~k~ $\vDash$  B 表示 B 是 A~1~ , A~2~ , … , A~k~ 的逻辑结论，在证明的序列中，若已有A~1~ , A~2~ , … , A~k~ ，则可引入B</p>
<ol>
<li>前提引入规则：在证明的任何一步，都可以引入前提</li>
<li>结论引入规则：在证明的任何一步，前面已经证明的结论都可作为后续证明的前提</li>
<li>置换规则：在证明的任何步骤上，命题公式中的任何子命题公式给都可以用与之等值的命题公式置换</li>
<li>假言推理规则：A $\rightarrow$ B, A $\vDash$ B</li>
<li>附加规则：A $\vDash$ A $\lor$ B</li>
<li>化简规则：A $\land$ B $\vDash$ A</li>
<li>拒取式规则：A $\rightarrow$ B, $\neg$ B $\vDash$ $\neg$ A</li>
<li>假言三段论规则：A $\rightarrow$ B, B $\rightarrow$ C $\vDash$ A $\rightarrow$ C</li>
<li>析取三段论规则：A $\lor$ B , $\neg$ B $\vDash$ A</li>
<li>构造性二难规则：A $\rightarrow$ B, C $\rightarrow$ D, A $\lor$ C $\vDash$ B $\lor$ D</li>
<li>破坏性二难规则：A $\rightarrow$ B, C $\rightarrow$ D, $\neg$ B $\lor$  $\neg$ D $\vDash$ $\neg$ A $\lor$  $\neg$ C</li>
<li>合取引入规则：A, B $\vDash$ A $\land$ B</li>
</ol>
<blockquote>
<p>  附加前提证明法</p>
</blockquote>
<p>(A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~) $\rightarrow$ (A $\rightarrow$ B)</p>
<p>$\Leftrightarrow$ $\neg$ (A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~) $\lor$ ($\neg$ A $\lor$ B)</p>
<p>$\Leftrightarrow$ $\neg$ (A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~ $\land$ A)  $\lor$ B</p>
<p>$\Leftrightarrow$ $\neg$ (A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~ $\land$ A) $\rightarrow$ B</p>
<p>原来结论中的前件A已经变成前提了，称A为<span class='p cyan'>附加前提</span>。</p>
<details class="folding-tag" red><summary> 例题 </summary>
              <div class='content'>
              <ul><li>前提：p $\rightarrow$ (q $\rightarrow$ r), $\neg$ s $\lor$ p, q</li><li>结论：s $\rightarrow$ r</li><li>证明：<ol><li>$\neg$ s $\lor$ p</li><li>s</li><li>p</li><li>p $\rightarrow$ (q $\rightarrow$ r)</li><li>q $\rightarrow$ r</li><li>q</li><li>r</li></ol></li></ul>
              </div>
            </details>
<blockquote>
<p>  归谬法</p>
</blockquote>
<p>若 A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~ 是可满足式， 则称 A~1~ , A~2~ , … , A~k~ 是<span class='p cyan'>相容的</span>， 否则是<span class='p cyan'>不相容的</span></p>
<p>（A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~）$\rightarrow$ B</p>
<p>$\Leftrightarrow$ $\neg$ （A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~）$\lor$ B</p>
<p>$\Leftrightarrow$ $\neg$ (A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~ $\land$ $\neg$ B)</p>
<p>若 A~1~ $\land$ A~2~ $\land$ $\cdots$ $\land$ A~k~ 与 $\neg$ B 不相容， 则说明 B 是 A~1~ , A~2~ , … , A~k~的<span class='p cyan'>逻辑结论</span>。</p>
<p>这种将$\neg$ B 作为附加前提推出矛盾的证明方法称为<span class='p cyan'>归谬法</span></p>
<details class="folding-tag" red><summary> 例题 </summary>
              <div class='content'>
              <ul><li>前提：p $\rightarrow$ ($\neg$ (r $\land$ s) $\rightarrow$ $\neg$ q), p, $\neg$ s</li><li>结论：$\neg$ q</li><li>证明；<pre><code>  1. p $\rightarrow$ ($\neg$ (r $\land$ s) $\rightarrow$ $\neg$ q）  2. p  3. $\neg$ (r $\land$ s) $\rightarrow$ $\neg$ q  4. $\neg$ ($\neg%$ q)  5. q  6. r $\land$ s  7. $\neg$ s  8. s  9. s $\land$ $\neg$ s  10. 矛盾式</code></pre></li></ul>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>若一个推理的形式结构与某条推理定律对应的蕴涵式一致，则不用证明就可断定这个推理是正确的。</li>
<li>等值式中的每一个都派生出两条推理定律。</li>
<li>由九条推理定律可以产生九条推理规则,它们构成了推理系统中的推理规则。</li>
<li>判断推理是否正确的三种方法：真值表法、等值演算法和主析取范式法。</li>
<li>对于正确的推理，在推理系统中构造证明的方法：推理系统的定义、推理规则、附加前提证明法、归谬法</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 易错集 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61cfef662ab3f51d91742596.png" alt=""><br><img src="https://pic.imgdb.cn/item/61cfef702ab3f51d91742ddd.png" alt=""></p>
              </div>
            </details>
<h2 id="一阶逻辑"><a href="#一阶逻辑" class="headerlink" title="一阶逻辑"></a>一阶逻辑</h2><h3 id="一阶逻辑基本概念"><a href="#一阶逻辑基本概念" class="headerlink" title="一阶逻辑基本概念"></a>一阶逻辑基本概念</h3><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>在命题逻辑中，研究的基本单位是简单命题，对简单命题不再进行分解，并且不考虑命题之间的内在联系和数量关系。所有的人都是要死的，苏格拉底是人，所以苏格拉底是要死的。这个简单而有名的苏格拉底三段论，却无法用命题逻辑予以证明。</li>
<li>一阶逻辑所研究的内容: 为了克服命题逻辑的局限性，将简单命题再细分，分析出个体词、谓词和量词，以期达到<span class='p blue'>表达出个体与总体的内在联系和数量关系</span>。</li>
</ul>
</div>
<blockquote>
<p>  个体词</p>
</blockquote>
<span class='p cyan'></span>个体词<span class='p cyan'></span>是指可以独立存在的客体，它可以是一个具体的事物，也可以是一个抽象的概念。

>   个体常项

表示具体的或特定的个体的词称为<span class='p cyan'>个体常项</span>，一般用小写的英文字母 *a, b, c, $\cdots$* 表示。

>   个体变项

表示抽象的，或泛指的个体的词称为<span class='p cyan'>个体变项</span>，常用小写字母 *x, y, z, $\cdots$* 表示。

>   个体域（论域）

个体变项的取值范围称为<span class='p cyan'>个体域（或论域）</span>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>个体域可以是有限的集合，也可以是无限的集合。当无特殊声明时，个体域有宇宙间的一切事物组成，称为<span class='p cyan'>全总个体域</span></p>
</div>
<blockquote>
<p>   谓词</p>
</blockquote>
<span class='p cyan'>谓词</span>是用来刻画个体词的性质或个体词之间关系的词

>   谓词常项、谓词变项

称表示具体性质或关系的谓词为<span class='p cyan'>谓词常项</span>，表示抽象的或泛指的谓词称为<span class='p cyan'>谓词变项</span>，均用大写英文字母 *F, G, H, $\cdots$*表示。

<div class="note icon-padding flat"><i class="note-icon fas fa-thumbs-up"></i><ul>
<li>个体变项 x 具有性质 F， 记作F（x）</li>
<li>个体变项 x, y 具有性质L， 记作L（x, y)</li>
</ul>
</div>
<blockquote>
<p>  元数、n元谓词</p>
</blockquote>
<p>谓词中包含的个体变项数称为<span class='p cyan'>元数</span></p>
<p>含 n (n $\geq$ 1)个个体变项的谓词称为 <span class='p cyan'>n元谓词</span></p>
<span class='p cyan'>一元谓词</span>表示性质

<span class='p cyan'>多元谓词</span>表示事物之间的关系

<span class='p cyan'>0元谓词</span> 不含个体变项的谓词，0元谓词都是命题。

<details class="folding-tag" blue><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61cffc002ab3f51d917e1190.png" alt=""><br><img src="https://pic.imgdb.cn/item/61cffc1f2ab3f51d917e2c19.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  量词</p>
</blockquote>
<p>表示个体常项或变项之间数量关系的词为<span class='p cyan'>量词</span></p>
<ol>
<li>==全称量词==对应日常语言中的“一切”，“所有的”，“任意的”等词，用符号 $\forall$ 表示。$\forall$ x F(x) 表示个体域里的所有个体都有性质F。</li>
<li>==存在量词==对应日常语言中的”存在着“，“有一个”，“至少有一个”等词，用符号 $\exists$ 表示。$\exists$ x F(x) 表示存在着个体域中的个体具有性质F。</li>
</ol>
<blockquote>
<p>  特性谓词</p>
</blockquote>
<p>在考虑符号化时必须先明确个体域<br><div class="note icon-padding flat"><i class="note-icon fas fa-thumbs-up"></i><p>个人理解：特性谓词的目的是从个体域中分离出一阶逻辑的范围条件</p>
</div><br><details class="folding-tag" red><summary> 例题 </summary>
              <div class='content'>
              <ul><li>(1) 所有人都要死的</li><li>(2) 有的人活百岁以上<ul><li>第一种情况，个体域D为人类集合<ul><li>(1) <em>$\forall$ x F(x)</em>，其中 <em>F(x)</em>：x是要死的</li><li>(2) <em>$\exists$ x F(x)</em>，其中 <em>F(x)</em>：x活百岁以上</li></ul></li><li>第二种情况，个体域D为全总个体域 M(x) 为特性谓词<ul><li>(1) <em>$\forall$ x (M(x) $\rightarrow$ F(x)</em> ，其中M(x) ：x是人</li><li>(2) <em>$\exists$ x (M(x) $\land$ G(x))</em> , 其中M(x) ：x是人<div class="note orange icon-padding flat"><i class="note-icon fas fa-exclamation-circle"></i><p>思考：在全总个体域中，能否将(1)符号化为$\forall$ x(M(x) $\land$ F(x))？ 能否将(2)符号化为$\exists$ x(M(x) $\rightarrow$ G(x))?</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>不可以，$\forall$ x(M(x) $\land$ F(x))表示表示宇宙中的万物都是人并且会呼吸显然是个假命题。$\exists$ x(M(x) $\rightarrow$ G(x))表示在宇宙万物中存在某个个体x,”如果X是人则X会用左手写字”,显然只要x不是人，上述论述就为真，因而它是个真命题。</p></div></div></div></li></ul></li></ul></li></ul>
              </div>
            </details></p>
<div class="note green icon-padding flat"><i class="note-icon fas fa-check-circle"></i><ul>
<li>如果事先没有给出个体域，都应以全总个体域为个体域</li>
<li>在引入特性谓词后，使用全称量词与存在量词符号化的形式是不同的</li>
<li>个体域和谓词的含义确定之后，n元谓词要转化为命题至少需要n个量词</li>
<li>当个体域为有限集时，如D= {a~1~ , a~2~, $\cdots$ , a~n~ } ,对于任意的谓词 A(x) ，都有<ul>
<li>$\forall$ x A(x) $\Leftrightarrow$ A(a~1~) $\land$ A(a~2~) $\land$ $\cdots$ $\land$ A(a~n~)</li>
<li>$\exists$ x A(x) $\Leftrightarrow$ A(a~1~) $\lor$ A(a~2~) $\lor$ $\cdots$ $\lor$ A(a~n~)<br>这实际上就是将一阶逻辑中命题公式转化为命题逻辑中的命题公式</li>
</ul>
</li>
<li>多个量词同时出现时，不能随意颠倒他们的顺序</li>
<li>有些命题的符号化形式可不止一种</li>
</ul>
</div>
<details class="folding-tag" blue><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d0039c2ab3f51d91849c07.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d003a92ab3f51d9184a6f0.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d003ce2ab3f51d9184c242.png" alt=""></p>
              </div>
            </details>
<h3 id="一阶逻辑合式公式及解析"><a href="#一阶逻辑合式公式及解析" class="headerlink" title="一阶逻辑合式公式及解析"></a>一阶逻辑合式公式及解析</h3><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p><span class='p cyan'>一阶语言</span>是用于一阶逻辑的形式语言，而一阶逻辑就是建立在一阶语言基础上的逻辑体系，一阶语言本身不具备任何意义，但可以根据需要被解释成具有某种含义。</p>
</div>
<blockquote>
<p>  符号表</p>
</blockquote>
<ol>
<li>个体常项：<em>a, b, c, $\cdots$ , a~i~ , b~i~ , c~i~ , $\cdots$ , i $\geq$ 1</em>;</li>
<li>个体变项：<em>x, y, z, $\cdots$ , x~i~ , y~i~ , z~i~ , $\cdots$ , i $\geq$ 1</em>;</li>
<li>函数符号：<em>f, g, h, $\cdots$ , f~i~ , g~i~ , h~i~ , $\cdots$ , i $\geq$ 1</em>;</li>
<li>谓词符号：<em>F, G, H, $\cdots$ , F~i~ , G~i~ , H~i~ , $\cdots$ , i $\geq$ 1</em>;</li>
<li>量词符号：$\exists$, $\forall$;</li>
<li>联结词符号：$\neg$, $\land$, $\lor$, $\rightarrow$, $\leftrightarrow$;</li>
<li>括号和逗号</li>
</ol>
<blockquote>
<p>  项</p>
</blockquote>
<p>项的递归定义：</p>
<ol>
<li>个体常项和个体变项是项</li>
<li>若$\Phi$ (x~1~, x~2~, …, x~n~)是任意的n元函数，t~1~ , t~2~, …, t~n~是任意的n个项，则$\Phi$ (t~1~, t~2~, …, t~n~)是<span class='p cyan'>项</span>。</li>
<li>只有有限次地使用1、2生成的符号串才是项。</li>
</ol>
<blockquote>
<p>  原子公式</p>
</blockquote>
<p>设R(x~1~, x~2~, … , x~n~)是任意n元谓词， t~1~, t~2~, … , t~n~是项，则称R(t~1~, t~2~, … , t~n~)是<span class='p cyan'>原子公式</span>。</p>
<blockquote>
<p>  合式公式</p>
</blockquote>
<p>合式公式的递归定义：</p>
<ol>
<li>原子公式是合式公式。</li>
<li>如果A是合式公式，则($\neg$ A)也是合式公式。</li>
<li>如果A、B是合式公式，则(A $\land$ B)、(A $\lor$ B)、(A $\rightarrow$ B)、(A $\leftrightarrow$ B) 也是合式公式。</li>
<li>如果A、B是合式公式，则$\forall$ xA、$\exists$ xA也是合式公式</li>
<li>只有有限次地应用1~4组成的符号串才是合式公式。<br>在一阶逻辑中合式公式又称为<span class='p cyan'>谓词公式</span>，简称<span class='p cyan'>公式</span>。</li>
</ol>
<blockquote>
<p>  指导变元（项）、辖域、约束出现、自由出现</p>
</blockquote>
<ul>
<li>在公式$\forall$ xA和$\exists$ xA中，称x为<span class='p cyan'>指导变元</span>。</li>
<li>在公式$\forall$ xA和$\exists$ xA中，A为相应量词的<span class='p cyan'>辖域</span>。</li>
<li>在$\forall$ x和$\exists$ x的辖域中，x的所有出现都称为<span class='p cyan'>约束出现</span>。</li>
<li>A中不是约束出现的其他变项均称为是<span class='p cyan'>自由出现</span>的。</li>
</ul>
<details class="folding-tag" green><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d00d2c2ab3f51d918c751d.png" alt=""></p>
              </div>
            </details>
<div class="note icon-padding flat"><i class="note-icon fas fa-thumbs-up"></i><p>特殊记法：</p>
<ol>
<li>用A(x~1~, x~2~, …, x~n~)表示含x~1~, x~2~, …, x~n~自由出现的公式。</li>
<li>用$\Delta$表示任意的量词$\forall$或$\exists$，则$\Delta$ x~1~A(x~1~, x~2~, …, x~n~)是含有x~2~, x~3~, …, x~n~自由出现的公式，可记为A~1~(x~2~, x~3~, …, x~n~)。</li>
</ol>
</div>
<blockquote>
<p>  闭式</p>
</blockquote>
<p>设A是任意的公式，若A中不含有自由出现的个体变项，则称A为封闭的公式，简称<span class='p cyan'>闭式</span>。</p>
<blockquote>
<p>  换名规则</p>
</blockquote>
<p>将一个指导变项及其在辖域中所有约束出现替换成公式中没有出现的个体变项符号。</p>
<blockquote>
<p>一阶公式的解释</p>
</blockquote>
<p>一阶公式没有确定的意义，一旦将其中的变项（项的变项、谓词变项）用指定的常项代替后，所得公式就具备一定的意义，有时就变成命题了。</p>
<details class="folding-tag" green><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d0212d2ab3f51d919c3d17.png" alt=""></p><div class="hide-block"><button type="button" class="hide-button" style="">点击有惊喜    </button><div class="hide-content"><p>有同学要问了，x,y也是变项，它不是还存在吗。其实这里用到了整体的思想，我们把整个函数看成项，x,y只是函数项的组成部分，这样看，是不是就是把项的变项变成了常项呢。当然不是绝对的，看情况而定。</p></div></div>
              </div>
            </details>
<p>一个<span class='p cyan'>解释I</span>由下面4个部分组成</p>
<ol>
<li>非空个体域D；</li>
<li>结论集的每一个个体变项符号指定一个D中的元素；</li>
<li>结论集的每一个函数变项符号指定一个D中的函数；</li>
<li>结论集的每一个谓词变项符号指定一个D中的谓词；</li>
</ol>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d02d232ab3f51d91a56d73.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/61d02d232ab3f51d91a56d6c.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/61d02d232ab3f51d91a56d3b.jpg" alt=""></p>
              </div>
            </details>
<div class="note orange icon-padding flat"><i class="note-icon fas fa-exclamation-circle"></i><p>被解释的公式不一定全部包含解释中的四部分。<br>封闭的公式在任何解释下都变成命题。<br>不是闭式的公式在某些解释下也可能变为命题。比如知道前件为假，但不知道后件结果，如此也是命题。</p>
</div>
<blockquote>
<p>  永真式、永假式、可满足式</p>
</blockquote>
<ul>
<li>设A为一个公式，若A在任何解释下均为真，则称A为<span class='p cyan'>永真式</span>(或称逻辑有效式)。</li>
<li>设A为一个公式，若A在任何解释下均为假，则称A为<span class='p cyan'>矛盾式</span>(或永假式)。</li>
<li>设A为一个公式，若至少存在一个解释使A为真，则称A为<span class='p cyan'>可满足式</span>。</li>
</ul>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>永真式一定是可满足式，但可满足式不一定是永真式。</li>
<li>在一阶逻辑中，到目前为止，还没有找到一种可行的算法，用来判断任意一个公式是否是可满足的，这与命题逻辑的情况是完全不同的。</li>
<li>但对某些特殊的公式还是可以判断的。</li>
</ol>
</div>
<blockquote>
<p>  代换实例</p>
</blockquote>
<p>设A~0~是含有命题变项p~1~, p~2~, …, p~n~的命题公式，A~1~, A~2~, …, A~n~是n个谓词公式，用A~i~(1 $\leq$ i $\leq$ n)处处代替A~0~中的p~i~，所得公式A称为A~0~的<span class='p cyan'>代换实例</span>。</p>
<p>重言式的代换实例都是永真式，矛盾式的代换实例都是矛盾式。</p>
<div class="note green icon-padding flat"><i class="note-icon fas fa-check-circle"></i><p>判断公式类型的方法：</p>
<ol>
<li>举例验证可满足式</li>
<li>代换实例求证</li>
</ol>
</div>
<h3 id="一阶逻辑等值式"><a href="#一阶逻辑等值式" class="headerlink" title="一阶逻辑等值式"></a>一阶逻辑等值式</h3><blockquote>
<p>  等值式</p>
</blockquote>
<p>设A，B是一阶逻辑中任意两个公式，若 A $\leftrightarrow$ B是永真式，则称A与B是等值的, 记做A $\Leftrightarrow$ B，称 A $\Leftrightarrow$ B 是<span class='p cyan'>等值式</span>。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>由于重言式都是逻辑有效式，因而1.3中给出的24个等值式及其代换实例都是一阶逻辑中的等值式。</li>
<li>判断公式A与B是否等值，等价于判断公式A $\leftrightarrow$ B是否为永真式。</li>
<li>重要等值式:<ul>
<li>代换实例</li>
<li>消去量词等值式</li>
<li>量词否定等值式</li>
<li>量词辖域收缩与扩张等值式</li>
<li>量词分配等值式</li>
</ul>
</li>
</ol>
</div>
<blockquote>
<p>  消去量词等值式</p>
</blockquote>
<ol>
<li>$\forall$xA(x) $\Leftrightarrow$ A(a~1~)$\land$A(a~2~)$\land$…$\land$A(a~n~)</li>
<li><p>$\exists$xA(x) $\Leftrightarrow$ A(a~1~)$\lor$A(a~2~)$\lor$…$\lor$A(a~n~)</p>
<div class="note blue icon-padding simple"><i class="note-icon fas-bullhorn"></i><p>当辖域前面有多个量词，在演算中先消去离辖域近的量词</p>
</div>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d1476a2ab3f51d915d6f1b.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d147852ab3f51d915d8cc3.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  量词否定等值式</p>
</blockquote>
</li>
<li><p>$\neg$$\forall$xA(x) $\Leftrightarrow$ $\exists$x$\neg$A(x)</p>
</li>
<li>$\neg$$\exists$xA(x) $\Leftrightarrow$ $\forall$x$\neg$A(x)<div class="note blue icon-padding simple"><i class="note-icon fas-bullhorn"></i><p>当辖域前面有多个量词，可以一步一步往辖域内靠近</p>
</div>
</li>
</ol>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d147ac2ab3f51d915db128.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  量词辖域收缩与扩张等值式</p>
</blockquote>
<ol>
<li>$\forall$x(A(x)$\lor$B) $\Leftrightarrow$ $\forall$xA(x)$\lor$B</li>
<li>$\forall$x(A(x)$\land$B) $\Leftrightarrow$ $\forall$xA(x)$\land$B</li>
<li>$\forall$x(A(x)$\rightarrow$B) $\Leftrightarrow$ $\exists$xA(x)$\rightarrow$B</li>
<li>$\forall$x(B$\rightarrow$A(x)) $\Leftrightarrow$ B$\rightarrow$$\forall$xA(x)</li>
<li>$\exists$x(A(x)$\lor$B) $\Leftrightarrow$ $\exists$xA(x)$\lor$B</li>
<li>$\exists$x(A(x)$\land$B) $\Leftrightarrow$ $\exists$xA(x)$\land$B</li>
<li>$\exists$x(A(x)$\rightarrow$B) $\Leftrightarrow$ $\forall$xA(x)$\rightarrow$B</li>
<li>$\exists$x(B$\rightarrow$A(x)) $\Leftrightarrow$ B$\rightarrow$$\exists$xA(x)</li>
</ol>
<blockquote>
<p>  量词分配等值式</p>
</blockquote>
<ol>
<li>$\forall$x(A(x)$\land$B(x)) $\Leftrightarrow$ $\forall$xA(x)$\land$$\forall$xB(x)</li>
<li>$\exists$x(A(x)$\lor$B(x)) $\Leftrightarrow$ $\exists$xA(x)$\lor$$\exists$xB(x)<div class="note orange icon-padding simple"><i class="note-icon fas fa-exclamation-circle"></i><p>全称量词“$\forall$”对“$\lor$”无分配律。<br>存在量词“$\exists$”对“$\land$”无分配律。</p>
</div>
</li>
</ol>
<blockquote>
<p>  一阶逻辑等值演算规则</p>
</blockquote>
<ol>
<li>==置换规则==：设$\Phi$(A)是含公式A的公式，$\Phi$(B)是用公式B取代$\Phi$(A)中所有的A之后的公式，若A$\Leftrightarrow$B，则$\Phi$(A)$\Leftrightarrow$$\Phi$(B)。</li>
<li>==换名规则==：设A为一公式，将A中某量词辖域中某约束变项的所有出现及相应的指导变元改成该量词辖域中未曾出现过的某个体变项符号，公式的其余部分不变，设所得公式为A’，则A’$\Leftrightarrow$A。</li>
<li>==代替规则==：设A为一公式，将A中某个自由出现的个体变项的所有出现用A中未曾出现过的个体变项符号代替，A中其余部分不变，设所得公式为A’，则A’$\Leftrightarrow$A。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>一阶逻辑中的置换规则与命题逻辑中的置换规则形式上完全相同，只是在这里A，B是一阶逻辑公式。</p>
</div>
</li>
</ol>
<h3 id="一阶逻辑前束范式"><a href="#一阶逻辑前束范式" class="headerlink" title="一阶逻辑前束范式"></a>一阶逻辑前束范式</h3><blockquote>
<p>  一阶逻辑前束范式</p>
</blockquote>
<p>设A为一个一阶逻辑公式，若A具有如下形式<br>            Q~1~x~1~Q~2~x~2~ … Q~k~x~k~B<br>则称A为<span class='p cyan'>前束范式</span>，其中Q~i~(1$\leq$i$\leq$k)为$\forall$或$\exists$，B为不含量词的公式。</p>
<div class="note orange icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>求前束范式的过程，就是制造量词辖域可以扩大的条件，进行量词辖域扩大。</li>
<li>任何公式的前束范式都是存在的，但一般说来，并不唯一。</li>
<li>利用一阶逻辑等值式以及三条变换规则（置换规则、换名规则、代替规则）就可以求出与公式等值的前束范式。</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d14dea2ab3f51d91635cd1.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d14ea72ab3f51d9163f4ba.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>当存在多个量词时，辖域扩张顺序是从右往左，也就是先提取出来的量词放到最右边。</p>
</div>
<h3 id="一阶逻辑推理理论"><a href="#一阶逻辑推理理论" class="headerlink" title="一阶逻辑推理理论"></a>一阶逻辑推理理论</h3><blockquote>
<p>  推理正确、推理定律</p>
</blockquote>
<ul>
<li>在一阶逻辑中，从前提A~1~, A~2~, …A~k~出发推结论B的推理形式结构，依然采用如下的蕴涵式形式A~1~ , A~2~ ,… , A~k~ $\rightarrow$ B。若为永真式，则称<span class='p cyan'>推理正确</span>，否则称推理不正确。</li>
<li>在一阶逻辑中称永真式的蕴涵式为<span class='p cyan'>推理定律</span>，若一个推理的形式结构正是某条推理定律，则这个推理显然是正确的。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在一阶逻辑的推理中，某些前提与结论可能是受量词限制，为了使用命题逻辑中的等值式和推理定律，必须在推理过程中有消去和添加量词的规则，以便使谓词演算公式的推理过程可类似于命题演算中推理理论那样进行。</p>
</div>
</li>
</ul>
<blockquote>
<p>  推理定律来源</p>
</blockquote>
<ol>
<li>命题逻辑推理定律的代换实例</li>
<li>由基本等值式生成的推理定律</li>
<li>量词分配等值式</li>
<li>推理规则—量词消去和引入规则</li>
</ol>
<blockquote>
<p>  推理规则</p>
</blockquote>
<p>为了构造推理系统，还要给出4条重要的推理规则,即消去量词和引入量词的规则：</p>
<ol>
<li>全称量词消去规则(简记为UI规则或UI)</li>
<li>全称量词引入规则(简记为UG规则或UG)</li>
<li>存在量词引入规则(简称EG规则或EG)</li>
<li>存在量词消去规则(简记为EI规则或EI)</li>
</ol>
<blockquote>
<p>  全称量词消去规则</p>
</blockquote>
<p>如果个体域的所有元素都具有性质A，则个体域中的任一元素具有性质A。</p>
<script type="math/tex; mode=display">\because \forall x A ( x ) \therefore A ( y )</script><script type="math/tex; mode=display">\because \forall x A ( x ) \therefore A ( c )</script><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>用y或c去取代A(x)中自由出现的x时，一定要在x自由出现的一切地方进行取代，且y在其他地方未约束出现过。</p>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d158132ab3f51d916c8e16.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  全称量词引入规则</p>
</blockquote>
<script type="math/tex; mode=display">\because A ( y )  \therefore \forall x A ( x )</script><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>无论A(y)中自由出现的个体变项y取何值，A(y)应该均为真。</li>
<li>取代自由出现的y的x也不能在A(y)中约束出现。</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d1582b2ab3f51d916ca574.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  存在量词引入规则</p>
</blockquote>
<script type="math/tex; mode=display">\because A ( c )  \therefore \exists x A ( x )</script><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>c是特定的个体常项</li>
<li>取代c的x不能在A(c)中出现过。</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d158562ab3f51d916ccd69.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  存在量词消去规则</p>
</blockquote>
<script type="math/tex; mode=display">\because \exists x A ( x ) \therefore A ( c )</script><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>c是使A为真的特定的个体常项。</li>
<li>c不在A(x)中出现。</li>
<li>若A(x)中除自由出现的x外，还有其它自由出现的个体变项，此规则不能使用。</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d159962ab3f51d916dfbf0.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  推理规则</p>
</blockquote>
<ol>
<li>前提引入规则</li>
<li>结论引入规则</li>
<li>置换规则</li>
<li>假言推理规则</li>
<li>附加规则</li>
<li>化简规则</li>
<li>拒取式规则</li>
<li>假言三段论规则</li>
<li>析取三段论规则</li>
<li>构造性二难推理规则</li>
<li>合取引入规则</li>
<li>UI规则</li>
<li>UG规则</li>
<li>EG规则</li>
<li>EI规则</li>
</ol>
<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d15ed22ab3f51d917248b0.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d15f7b2ab3f51d9172cf85.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d15f872ab3f51d9172d966.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d1608b2ab3f51d9173aa09.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d16e662ab3f51d917f95e2.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d16e722ab3f51d917f9f78.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在证明序列中先引进带存在量词的前提。</p>
</div>
<h2 id="集合的基本概念和运算"><a href="#集合的基本概念和运算" class="headerlink" title="集合的基本概念和运算"></a>集合的基本概念和运算</h2><h3 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h3><blockquote>
<p>  集合、元素</p>
</blockquote>
<p>集合(Set)是不能精确定义的基本概念。直观地说，把一些事物汇集到一起组成一个整体就叫集合，而这些事物就是这个集合的元素或成员。集合通常用大写的英文字母来标记。</p>
<blockquote>
<p>  常见的数的集合</p>
</blockquote>
<ul>
<li>N—自然数集合</li>
<li>Z—整数集合</li>
<li>Q—有理数集合</li>
<li>R—实数集合</li>
<li>C—复数集合</li>
</ul>
<blockquote>
<p>  集合的表示方法</p>
</blockquote>
<ol>
<li>列元素法(列出集合的所有元素，元素之间用逗号隔开，并把它们用花括号括起来) <details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p>A＝{a，b，c，…，z}<br>Z＝{0，±1，±2，…}<br>C＝{桌子,灯泡,老虎,自然数}</p>
              </div>
            </details></li>
<li>谓词表示法(用谓词来概括集合中元素的属性) <details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p>B＝{x|x∈R∧x^2^－1＝0}</p>
              </div>
            </details>
</li>
</ol>
<blockquote>
<p>   集合的元素</p>
</blockquote>
<ol>
<li>集合的元素是彼此不同的，如果同一个元素在集合中多次出现应该认为是一个元素。</li>
<li>集合的元素是无序的。</li>
<li>一般来说，集合的元素可以是任何类型的事物，一个集合也可以作为另一个集合的元素。</li>
</ol>
<blockquote>
<p>  元素和集合之间的关系</p>
</blockquote>
<p>元素和集合之间的关系是隶属关系，即属于或不属于，属于记作$\in$，不属于记作∉</p>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p>例如：A＝{a，{b，c}，d，}中，a∈A，{b，c}∈A，d∈A，∈A，b∉A，{d}∉A。b和{d}是A的元素的元素。<br><img src="https://pic.imgdb.cn/item/61d19ab32ab3f51d91a2df36.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>隶属关系可以看作是处在不同层次上的集合之间的关系。</li>
<li>规定：对任何集合A都有A∉A。</li>
</ol>
</div>
<blockquote>
<p>  集合间关系</p>
</blockquote>
<ul>
<li>设A，B为集合，如果B中的每个元素都是A中的元素，则称B是A的子集合，简称<span class='p cyan'>子集</span>。这时也称B被A<span class='p cyan'>包含</span>，或A包含B，记作 B$\subseteq$A，不包含记作$\subsetneq$。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>显然对任何集合A都有A $\subseteq$ A。</li>
<li>隶属关系和包含关系都是两个集合之间的关系，对于某些集合可以同时成立这两种关系。例如 A＝{a，{a}}和{a}既有{a}∈A，又有{a}∉A。前者把它们看成是不同层次上的两个集合，后者把它们看成是同一层次上的两个集合。</li>
</ol>
</div></li>
<li>设A，B为集合，如果 A$\subseteq$B 且 B$\subseteq$A，则称A与B<span class='p cyan'>相等</span>，记作A＝B。如果A与B不相等，则记作A≠B。相等的符号化表示为：A＝B $\Leftrightarrow$ A$\subseteq$B $\land$ B$\subseteq$A</li>
<li>设A，B为集合，如果 B$\subseteq$A 且 B≠A，则称B是A的<span class='p cyan'>真子集</span>，记作B$\subset$A。</li>
<li>不含任何元素的集合叫做<span class='p cyan'>空集</span>，记作$\emptyset$。空集的符号化表示为：$\emptyset$ ＝{x|x≠x}。由定义可知，空集并不是集合的元素。</li>
</ul>
<blockquote>
<p>  空集的性质</p>
</blockquote>
<ol>
<li>空集是一切集合的子集。</li>
<li>空集是唯一的。</li>
</ol>
<blockquote>
<p>  n元集</p>
</blockquote>
<p>含有n个元素的集合简称<span class='p cyan'>n元集</span>，它的含有m(m≤n)个元素的子集叫做它的<span class='p cyan'>m元子集</span>。</p>
<blockquote>
<p>  幂集</p>
</blockquote>
<p>一般地说，对于n元集A，它的0元子集有 $C<em>{n}^{0}$ 个，1元子集有 $C</em>{n}^{1}$ 个，…，m元子集有 $C<em>{n}^{m}$ 个，…，n元子集有 $C</em>{n}^{n}$  个。子集总数为</p>
<script type="math/tex; mode=display">C _ { n } ^ { 0 } + C _ { n } ^ { 1 } + C _ { n } ^ { 2 } + \cdots + C _ { n } ^ { n } = 2 ^ { n }</script><p>设A为集合，把A的全部子集构成的集合叫做A的<span class='p cyan'>幂集</span>，记作P(A)(或PA，2^A^)。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>幂集的符号化表示为P(A)＝{x | x$\subseteq$A}</li>
<li>若A是n元集，则P(A)有 2^n^ 个元素。</li>
</ul>
</div>
<blockquote>
<p>  全集</p>
</blockquote>
<p>在一个具体问题中，如果所涉及的集合都是某个集合的子集，则称这个集合为<span class='p cyan'>全集</span>，记作E。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>全集是有相对性的，不同的问题有不同的全集，即使是同一个问题也可以取不同的全集。</li>
<li>例如，在研究整数的问题时，可以把整数集Z取作全集</li>
<li>一般地说，全集取得小一些，问题的描述和处理会简单些。</li>
</ul>
</div>
<h3 id="集合的基本运算"><a href="#集合的基本运算" class="headerlink" title="集合的基本运算"></a>集合的基本运算</h3><blockquote>
<p>  并集、交集、相对补集</p>
</blockquote>
<p>设A，B为集合，A与B的并集A$\cup$B，交集A$\cap$B ，B对A的相对补集A－B分别定义如下：</p>
<script type="math/tex; mode=display">A \cup B = \{ x | x \in A \lor x \in B \}</script><script type="math/tex; mode=display">A \cap B = \{ x | x \in A \land x \in B \}</script><p><img src="https://pic.imgdb.cn/item/61d1ca9e2ab3f51d91c93095.png" alt=""></p>
<ul>
<li>如果两个集合的交集为$\emptyset$，则称这两个集合是<span class='p cyan'>不相交</span></li>
<li>两个集合的并和交运算可以推广成n个集合的并和交：<script type="math/tex; mode=display">A _ { 1 } \cup A _ { 2 } \cup \ldots \cup A _ { n } = \{ x | x \in A _ { 1 } \lor x \in A _ { 2 } \lor \ldots \lor x \in A _ { n } \}</script><script type="math/tex; mode=display">A _ { 1 } \cap A _ { 2 } \cap \ldots \cap A _ { n } = \{ x | x \in A _ { 1 } \land x \in A _ { 2 } \land \ldots \land x \in A _ { n } \}</script></li>
<li>两个集合的并和交运算可以推广到无穷多个集合的情况：<script type="math/tex; mode=display">\cup _ { i = 1 } ^ { \infty } A _ { i } = A _ { 1 } \cup A _ { 2 } \cup _ { \ldots }</script><script type="math/tex; mode=display">\cap _ { i = 1 } ^ { \infty } A _ { i } = A _ { 1 } \cap A _ { 2 } \cap _ { \ldots }</script></li>
</ul>
<blockquote>
<p>  对称差集</p>
</blockquote>
<p>设A，B为集合，A与B的对称差集 A$\bigoplus$B定义为：A$\bigoplus$B＝(A－B)$\cup$(B－A) 或者 A$\bigoplus$B＝(A$\cup$B)-(A $\cap$ B)</p>
<blockquote>
<p>  绝对补集</p>
</blockquote>
<p>设E为全集，A $\subseteq$ E，则称A对E的相对补集为A的<span class='p cyan'>绝对补集</span>，记作~A，即~A = E - A</p>
<blockquote>
<p>  文氏图</p>
</blockquote>
<ul>
<li>集合之间的关系和运算可以用文氏图给予形象的描述。</li>
<li>文氏图的构造方法如下：<ol>
<li>画一个大矩形表示全集E(有时为简单起见可将全集省略)。</li>
<li>在矩形内画一些圆(或任何其它的适当的闭曲线)，用圆的内部表示集合。</li>
<li>不同的圆代表不同的集合。如果没有关于集合不交的说明，任何两个圆彼此相交。</li>
<li>图中阴影的区域表示新组成的集合。</li>
<li>可以用实心点代表集合中的元素。</li>
</ol>
</li>
</ul>
<blockquote>
<p>  有穷集的计数问题</p>
</blockquote>
<p>使用文氏图可以很方便地解决有穷集的计数问题:</p>
<pre><code>1. 首先根据已知条件把对应的文氏图画出来。一般地说，每一条性质决定一个集合。有多少条性质，就有多少个集合。如果没有特殊说明，任何两个集合都画成相交的
2. 然后将已知集合的元素数填入表示该集合的区域内。通常从n个集合的交集填起，根据计算的结果将数字逐步填入所有的空白区域。如果交集的数字是未知的，可以设为x。
3. 根据题目中的条件，列出一次方程或方程组，就可以求得所需要的结果。
</code></pre><details class="folding-tag" red><summary> 例题 </summary>
              <div class='content'>
              <p>题目：对24名会外语的科技人员进行掌握外语情况的调查。其统计结果如下：会英、日、德和法语的人分别为13，5，10和9人，其中同时会英语和日语的有2人，会英、德和法语中任两种语言的都是4人。已知会日语的人既不懂法语也不懂德语，分别求只会一种语言(英、德、法、日)的人数和会三种语言的人数。<br>解：令A，B，C，D分别表示会英、法、德、日语的人的集合。根据题意画出文氏图。设同时会三种语言的有x人，只会英、法或德语一种语言的分别为y1，y2和y3人。将x和y1，y2，y3填入图中相应的区域，然后依次填入其它区域的人数。<br><img src="https://pic.imgdb.cn/item/61d1d2132ab3f51d91cee360.png" alt=""></p>
              </div>
            </details>、

>   包含排斥原理

设S为有穷集，P~1~,P~2~,…,P~m~是m个性质。S中的任何元素x或者具有性质P~i~，或者不具有性质P~i~(i=1,2,…m),两种情况必居其一。令A~i~表示S中具有性质P~k~的元素构成的子集，则S中不具有性质P~1~,P~2~,…,P~m~的元素为
![](https://pic.imgdb.cn/item/61d1d57c2ab3f51d91d1ae28.png)

推论：S中至少具有一条性质的元素数为
![](https://pic.imgdb.cn/item/61d1d59a2ab3f51d91d1c410.png)

<details class="folding-tag" cyan><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d1d6be2ab3f51d91d28eac.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d1d6c72ab3f51d91d294ef.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d1d6cf2ab3f51d91d29a21.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  广义并和广义交</p>
</blockquote>
<ul>
<li>设A为集合，A的元素的元素构成的集合称为A的广义并，记为∪A。符号化表示为∪A＝{x | $\exists$z(z∈A∧x∈z)}</li>
<li>设A为非空集合，A的所有元素的公共元素构成的集合称为A的广义交，记为$\cap$A。符号化表示为$\cap$A＝{x | $\forall$z(z∈A$\rightarrow$x∈z)}<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d25f412ab3f51d9112cffc.png" alt=""></p>
              </div>
            </details>
</li>
</ul>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>若A＝{A~1~,A~2~,…,A~n~}，则∪A＝A~1~∪A~2~∪…∪A~n~</li>
<li>若A＝{A~1~,A~2~,…,A~n~}，则$\cap$A＝A~1~$\cap$A~2~$\cap$…$\cap$A~n~</li>
<li>在后面的叙述中，若只说并或交，则这都是指集合的初级并或初级交；如果在并或交前边冠以“广义”两个字，则指集合的广义并或广义交。</li>
<li>为了使得集合表达式更为简洁，我们对集合运算的优先顺序做如下规定：<ol>
<li>称广义并、广义交、幂集、绝对补运算为一类运算</li>
<li>并、交、相对补、对称差运算为二类运算。</li>
<li>一类运算优先于二类运算</li>
<li>一类运算之间由右向左顺序进行</li>
<li>二类运算之间由括号决定先后顺序。</li>
</ol>
</li>
</ul>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2611f2ab3f51d91140e20.png" alt=""></p>
              </div>
            </details>
<h3 id="集合恒等式"><a href="#集合恒等式" class="headerlink" title="集合恒等式"></a>集合恒等式</h3><details class="folding-tag" cyan><summary> 集合恒等式 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d286892ab3f51d912f68d5.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2763d2ab3f51d91239375.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 集合运算性质 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2813f2ab3f51d912b6fac.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>对偶式：一个集合表达式，如果只含有$\cap$、$\cup$、～、$\emptyset$、E、＝、$\subseteq$、$\supseteq$，那么同时把$\cap$与$\cup$互换，把$\emptyset$与E互换，把$\subseteq$与$\supseteq$互换，得到式子称为原式的<span class='p cyan'>对偶式</span>。<br>对欧原理：对偶式同真假。或者说，集合恒等式的对偶式还是恒等式。</p>
</div>
<blockquote>
<p>  集合恒等式的证明方法</p>
</blockquote>
<ol>
<li>逻辑演算法：利用逻辑等值式和推理规则。</li>
<li>集合演算法：利用集合恒等式和已知结论。</li>
</ol>
<details class="folding-tag" green><summary> 逻辑演算法的格式 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2841f2ab3f51d912db38e.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 集合演算法的格式 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d284b22ab3f51d912e0f0f.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d285482ab3f51d912e7f8e.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d285c92ab3f51d912edb63.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d286012ab3f51d912f046f.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d28aee2ab3f51d9132ab34.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d28b0f2ab3f51d9132c5b5.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d28bc62ab3f51d91336041.png" alt=""></p>
              </div>
            </details>
<h2 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h2><h3 id="有序对与笛卡尔积"><a href="#有序对与笛卡尔积" class="headerlink" title="有序对与笛卡尔积"></a>有序对与笛卡尔积</h3><blockquote>
<p>  有序对</p>
</blockquote>
<p>由两个元素x和y（允许x=y）按一定顺序排列成的二元组叫做一个<span class='p cyan'>有序对</span>(ordered pair)或<span class='p cyan'>序偶</span>，记作<x,y>，其中x是它的第一元素，y是它的第二元素。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>有序对<x,y>具有以下性质：</p>
<pre><code>1. 当x≠y时，&lt;x,y&gt;≠&lt;y,x&gt;。
2. &lt;x,y&gt;＝&lt;u,v&gt;的充分必要条件是x＝u且y＝v。
</code></pre></div>
<blockquote>
<p>  笛卡尔积</p>
</blockquote>
<ul>
<li>设A，B为集合,用A中元素为第一元素，B中元素为第二元素构成有序对。所有这样的有序对组成的集合叫做A和B的<span class='p cyan'>笛卡儿积</span>(Cartesian product)，记作A×B。</li>
<li>笛卡儿积的符号化表示为A×B＝{<x,y>|x∈A∧y∈B}</li>
<li>如果|A|=m,|B|=n,则|A×B|=mn。<details class="folding-tag" blue><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d291862ab3f51d9138bdd9.png" alt=""></p>
              </div>
            </details>
</li>
</ul>
<blockquote>
<p>  笛卡儿积的运算性质</p>
</blockquote>
<ol>
<li>对任意集合A，根据定义有A×$\emptyset$＝$\emptyset$, $\emptyset$×A＝$\emptyset$</li>
<li>一般的说，笛卡儿积运算不满足交换律，即A×B≠B×A (当 A≠$\emptyset$ ∧ B≠$\emptyset$ ∧ A≠B 时)</li>
<li>笛卡儿积运算不满足结合律，即(A×B)×C≠A×(B×C)    (当 A≠$\emptyset$ ∧ B≠$\emptyset$ ∧ C≠$\emptyset$ 时)</li>
<li>笛卡儿积运算对并和交运算满足分配律，即<br> A×(B∪C)=(A×B)∪(A×C)<br> (B∪C)×A=(B×A)∪(C×A)<br> A×(B$\cap$C)=(A×B)$\cap$(A×C)<br> (B$\cap$C)×A=(B×A)$\cap$(C×A)</li>
<li>A$\subseteq$C $\land$ B$\subseteq$D $\Rightarrow$ A×B $\subseteq$ C×D</li>
</ol>
<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2933c2ab3f51d913a204b.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d293732ab3f51d913a49e8.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2988b2ab3f51d913e80d4.png" alt=""></p>
              </div>
            </details>
<h3 id="二元关系-1"><a href="#二元关系-1" class="headerlink" title="二元关系"></a>二元关系</h3><p>如果一个集合满足以下条件之一：<br>    （1）集合非空，且它的元素都是有序对<br>    （2）集合是空集<br>则称该集合为一个<span class='p cyan'>二元关系</span>，记作R。二元关系也可简称为关系。对于二元关系R，如果<x,y>∈R，可记作xRy；</p>
<blockquote>
<p>  A上的二元关系</p>
</blockquote>
<p>设A，B为集合，A×B的任何子集所定义的二元关系叫做从<span class='p cyan'>A到B的二元关系</span>；特别当A=B时，则叫做<span class='p cyan'>A上的二元关系</span>。<br><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>集合A上的二元关系的数目依赖于A中的元素数。如果|A|=n，那么|A×A|=n^2^， A×A的子集就有2<sup>n<sup>2</sup>&lt;/sup&gt; 个。每一个子集代表一个A上的二元关系，所以A上有2<sup>n<sup>2</sup>&lt;/sup&gt; 个不同的二元关系。例如|A|=3，则A上有2<sup>3<sup>2</sup>&lt;/sup&gt; 个不同的二元关系。</p>
</div></p>
<blockquote>
<p>  常用的关系</p>
</blockquote>
<p>对任意集合A，定义</p>
<ol>
<li>全域关系 E~A~={<x,y>|x∈A∧y∈A}=A×A</li>
<li>恒等关系 I~A~={<x,x>|x∈A}</li>
<li>空关系   $\emptyset$</li>
<li>小于或等于关系：L~A~={<x,y>|x,y∈A∧x≤y}，其中 A$\subseteq$R。</li>
<li>整除关系：D~B~={<x,y>|x,y∈B∧x整除y}，其中 A$\subseteq$Z*，Z*是非零整数集</li>
<li>包含关系：R$\subseteq$＝{<x,y>|x,y∈A∧x$\subseteq$y}，其中 A是集合族。</li>
</ol>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2a1fe2ab3f51d9149b68f.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2a27e2ab3f51d914a1f9b.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  关系表示法</p>
</blockquote>
<ol>
<li>集合表达式</li>
<li>关系矩阵</li>
<li>关系图</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>关系矩阵和关系图可以表示有穷集上的关系。</p>
</div>
<details class="folding-tag" blue><summary> 定义 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2a3522ab3f51d914ace61.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2a35f2ab3f51d914ad915.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" blue><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2a3802ab3f51d914af7a7.png" alt=""></p>
              </div>
            </details>
<h3 id="二元关系的运算"><a href="#二元关系的运算" class="headerlink" title="二元关系的运算"></a>二元关系的运算</h3><blockquote>
<p>  定义域、值域、域</p>
</blockquote>
<p>设R是二元关系。</p>
<ol>
<li>R中所有有序对的第一元素构成的集合称为R的<span class='p cyan'>定义域</span>(domain)，记为dom R。形式化表示为：dom R ＝ {x | $\exists$y(<x,y>∈R )}</li>
<li>R中所有有序对的第二元素构成的集合称为R的<span class='p cyan'>值域</span>(range) ，记作ran R。形式化表示为：ran R＝{y | $\exists$ x(<x,y>∈R)}</li>
<li>R的定义域和值域的并集称为R的<span class='p cyan'>域</span>(field)，记作fld R。形式化表示为；fld R＝dom R ∪ ran R</li>
</ol>
<blockquote>
<p>  关系的逆和右复合</p>
</blockquote>
<ul>
<li>设R为二元关系，R的逆关系，简称R的<span class='p cyan'>逆</span>(inverse)，记作R^-1^,其中R^-1^＝{<x,y>|<y,x>∈R}</li>
<li>设F,G为二元关系，G对F的<span class='p cyan'>右复合</span>(composite)记作F$\circ$G，其中F$\circ$G＝{<x,y> | $\exists$t(<x,t>∈F∧<t,y>∈G)}</li>
</ul>
<blockquote>
<p>  关系的限制和像</p>
</blockquote>
<p>设R为二元关系，A是集合</p>
<ol>
<li>R在A上的<span class='p cyan'>限制</span>(restriction)记作R↑A，其中R↑A={<x,y>|xRy∧x∈A}</li>
<li>A在R下的<span class='p cyan'>像</span>(image)记作R[A]，其中R[A]=ran(R↑A)</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>R在A上的限制R↑A是R的子关系。</li>
<li>A在R下的像R[A]是ran R的子集。</li>
</ol>
</div>
<blockquote>
<p>  关系与集合</p>
</blockquote>
<ol>
<li>关系是集合，集合运算对于关系也是适用的。</li>
<li>规定：<ul>
<li>关系运算中逆运算优先于其它运算</li>
<li>所有的关系运算都优先于集合运算</li>
<li>优先权的运算以括号决定运算顺序<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2a9af2ab3f51d91510343.png" alt=""></p>
              </div>
            </details>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>  定理</p>
</blockquote>
<ol>
<li>设F是任意的关系，则<ul>
<li>(F^-1^)^-1^＝F</li>
<li>dom F~-1~＝ran F，ran F~-1~＝dom F<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b4272ab3f51d915dc15e.png" alt=""></p>
              </div>
            </details></li>
</ul>
</li>
<li>设F，G，H是任意的关系，则<ul>
<li>(F$\circ$G)$\circ$H＝F$\circ$(G$\circ$H)</li>
<li>(F$\circ$G)^-1^＝G^-1^ $\circ$ F^-1^<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b4662ab3f51d915e06d6.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2b46f2ab3f51d915e0e72.png" alt=""></p>
              </div>
            </details></li>
</ul>
</li>
<li>设R为A上的关系，则R $\circ$ I~A~＝I~A~ $\circ$ R＝R <details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b47b2ab3f51d915e1b4e.png" alt=""></p>
              </div>
            </details></li>
<li>设F，G，H是任意的关系，则<ul>
<li>F$\circ$(G∪H)＝F$\circ$G∪F$\circ$H</li>
<li>(G∪H)$\circ$F＝G$\circ$F∪H$\circ$F</li>
<li>F$\circ$(G$\cap$H)$\subseteq$F$\circ$G$\cap$F$\circ$H</li>
<li>(G$\cap$H)$\circ$F $\subseteq$G$\circ$F$\cap$H$\circ$F<details class="folding-tag" cyan><summary> 定理四的推论 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b3112ab3f51d915cec08.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b48a2ab3f51d915e26fb.png" alt=""></p>
              </div>
            </details></li>
</ul>
</li>
<li>设F为关系，A,B为集合，则<ul>
<li>F↑(A∪B)＝F↑A∪F↑B</li>
<li>F[A∪B]＝F[A]∪F[B]</li>
<li>F↑(A$\cap$B)＝F↑A$\cap$F↑B</li>
<li>F[A$\cap$B]$\subseteq$F[A]$\cap$F[B]<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2b4982ab3f51d915e3348.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2b4ae2ab3f51d915e44ac.png" alt=""></p>
              </div>
            </details>
</li>
</ul>
</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>通过上述证明我们可以发现其本质是从定义入手</p>
</div>
<blockquote>
<p>  关系的幂运算</p>
</blockquote>
<p>设R为A上的关系，n为自然数，则R的n次幂定义为：</p>
<ol>
<li>R^0^＝{<x,x>|x∈A}＝I~A~</li>
<li>R^n+1^＝R^n^ $\circ$ R</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>对于A上的任何关系R~1~和R~2~都有R~1~^0^＝R~2~^0^＝I~A~ 即：A上任何关系的0次幂都相等，都等于A上的恒等关系I~A~。</li>
<li>对于A上的任何关系R都有R^1^＝R，因为R^1^＝R^0^ $\circ$ R＝I^A^ $\circ$ R＝R</li>
</ol>
</div>
<blockquote>
<p>  R^n^的计算</p>
</blockquote>
<ol>
<li>如果R是用集合表达式给出的，可以通过n-1次右复合计算得到R^n^。</li>
<li>如果R是用关系矩阵M给出的，则Rn的关系矩阵是Mn，即n个矩阵M之积。与普通矩阵乘法不同的是，其中的相加是逻辑加，即1+1＝1，1+0＝0+1＝1，0+0＝0</li>
<li>如果R是用关系图G给出的，可以直接由图G得到Rn的关系图G’。G’的顶点集与G相同。考察G的每个顶点x~i~，如果在G中从x~i~出发经过n步长的路径到达顶点x~j~，则在G’中加一条从x~i~到x~j~ 的边。当把所有这样的便都找到以后，就得到图G’。</li>
</ol>
<details class="folding-tag" blue><summary> 例题 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2e9242ab3f51d918c90f8.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2ecde2ab3f51d918f6d5e.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  幂运算的性质</p>
</blockquote>
<ul>
<li>设A为n元集，R是A上的关系，则存在自然数s和t,使得R^s^=R^t^。</li>
<li>设R是A上的关系，m,n∈N，则<ol>
<li>R^m^ $\circ$ R^n^＝R^m+n^</li>
<li>(R^m^)^n^＝R^mn^<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2ee952ab3f51d9190b88c.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2eea82ab3f51d9190c681.png" alt=""></p>
              </div>
            </details></li>
</ol>
</li>
<li>设R是A上的关系，若存在自然数s,t(s&lt;t)使得R^s^=R^t^，则<ol>
<li>对任何k∈N有 R^s+k^=R^t+k^</li>
<li>对任何k,i∈N有 R^s+kp+i^=R^s+i^，其中p=t-s</li>
<li>令S={R^0^，R^1^，…，R^t-1^}，则对于任意的q∈N有 R^q^∈S<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d2f0042ab3f51d9191bd84.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d2f0102ab3f51d9191c733.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>有穷集A上的关系R的幂序列R^0^，R^1^，…是一个周期性变化的序列。就象正弦函数一样，利用它的周期性可以将R的高次幂化简为R的低次幂。</p>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3b7122ab3f51d91ff4ce5.png" alt=""></p>
              </div>
            </details>
</li>
</ol>
</li>
</ul>
<h3 id="二元关系的性质"><a href="#二元关系的性质" class="headerlink" title="二元关系的性质"></a>二元关系的性质</h3><blockquote>
<p>  自反性和反自反性</p>
</blockquote>
<p>设R为A上的关系，</p>
<ol>
<li>若$\forall$x(x∈A→<x,x>∈R)，则称R在A上是<span class='p cyan'>自反</span>(reflexivity)的。</li>
<li>若$\forall$x(x∈A→<x,x>∉R)，则称R在A上是<span class='p cyan'>反自反</span>(irreflexivity)的。</li>
</ol>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <ol><li>全域关系E~A~，恒等关系I~A~，小于等于关系L~A~，整除关系D~A~都是为A上的自反关系。</li><li>包含关系R是给定集合族A上的自反关系。</li><li>小于关系和真包含关系都是给定集合或集合族上的反自反关系。<br><img src="https://pic.imgdb.cn/item/61d3bbf52ab3f51d9104e667.png" alt=""></li></ol>
              </div>
            </details>
<blockquote>
<p>  对称性和反对称性</p>
</blockquote>
<p>设R为A上的关系，</p>
<ol>
<li>若$\forall$x$\forall$y(x,y∈A∧<x,y>∈R→<y,x>∈R)，则称R为A上<span class='p cyan'>对称</span>(symmetry)的关系。</li>
<li>若$\forall$x$\forall$y(x,y∈A∧<x,y>∈R∧<y,x>∈R→x=y)，则称R为A上的<span class='p cyan'>反对称</span>(antisymmetry)关系。</li>
</ol>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <ol><li>A上的全域关系E~A~，恒等关系I~A~和空关系都是A上的对称关系。</li><li>恒等关系I~A~和空关系也是A上的反对称关系。</li><li>但全域关系E~A~一般不是A上的反对称关系，除非A为单元集或空集。<br><img src="https://pic.imgdb.cn/item/61d3bc0a2ab3f51d9104f438.png" alt=""></li></ol>
              </div>
            </details>
<blockquote>
<p>  传递性</p>
</blockquote>
<p>设R为A上的关系，<br>$\forall$x$\forall$y$\forall$z(x,y,z∈A∧<x,y>∈R∧<y,z>∈R→<x,z>∈R)<br>则称R是A上的<span class='p cyan'>传递</span>(transitivity)关系。</p>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <ol><li>A上的全域关系E~A~，恒等关系I~A~和空关系都是A上的传递关系。</li><li>小于等于关系，整除关系和包含关系也是相应集合上的传递关系。</li><li>小于关系和真包含关系仍旧是相应集合上的传递关系。<br><img src="https://pic.imgdb.cn/item/61d3c3cd2ab3f51d9110c337.png" alt=""></li></ol>
              </div>
            </details>
<blockquote>
<p>  二元关系性质的等价描述</p>
</blockquote>
<p>设R为A上的关系，则</p>
<ol>
<li>R在A上自反当且仅当 I~A~ $\subseteq$ R</li>
<li>R在A上反自反当且仅当 R$\cap$I~A~＝$\emptyset$</li>
<li>R在A上对称当且仅当 R＝R^-1^</li>
<li>R在A上反对称当且仅当 R$\cap$R^-1^ $\subseteq$I~A~</li>
<li>R在A上传递当且仅当 R$\circ$R$\subseteq$R</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>利用该定理可以从关系的集合表达式来判断或证明关系的性质。</p>
</div>
<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3c4db2ab3f51d91126d81.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c4e52ab3f51d91127e03.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c4ef2ab3f51d91128cbc.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c4f72ab3f51d91129312.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c5082ab3f51d9112b788.png" alt=""></p>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3c5402ab3f51d91132a87.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c54e2ab3f51d91134cdf.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3c5552ab3f51d91135c89.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  二元关系性质的特点</p>
</blockquote>
<details class="folding-tag" cyan open><summary> 特点 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自反性</th><th style="text-align:center">反自反性</th><th style="text-align:center">对称性</th><th style="text-align:center">反对称性</th><th style="text-align:center">传递性</th></tr></thead><tbody><tr><td style="text-align:center">集合表达式</td><td style="text-align:center">I~A~ $\subseteq$ R</td><td style="text-align:center">R $\cap$ I~A~ = $\emptyset$</td><td style="text-align:center">R = R^-1^</td><td style="text-align:center">R $\cap$ R ^-1^ $\subseteq$ I~A~</td><td style="text-align:center">R $\circ$ R $\subseteq$ R</td></tr><tr><td style="text-align:center">关系矩阵</td><td style="text-align:center">主对角线元素全是1</td><td style="text-align:center">主对角线元素全是0</td><td style="text-align:center">矩阵是对称矩阵</td><td style="text-align:center">若r~ij~＝1，且i≠j，则r~ji~＝0</td><td style="text-align:center">对M^2^中1所在位置，M中相应的位置都是1</td></tr><tr><td style="text-align:center">关系图</td><td style="text-align:center">每个顶点都有环</td><td style="text-align:center">每个顶点都没有环</td><td style="text-align:center">如果两个顶点之间有边，一定是一对方向相反的边(无单边)</td><td style="text-align:center">如果两点之间有边，一定是一条有向边(无双向边)</td><td style="text-align:center">如果顶点x~i~到x~j~有边，x~j~到x~k~有边，则从x~i~到x~k~也有边</td></tr></tbody></table></div>
              </div>
            </details>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3c7ff2ab3f51d9117f39a.png" alt=""></p>
              </div>
            </details>
<h3 id="二元关系的闭包"><a href="#二元关系的闭包" class="headerlink" title="二元关系的闭包"></a>二元关系的闭包</h3><blockquote>
<p>  闭包的定义</p>
</blockquote>
<p>设R是非空集合A上的关系，R的自反（对称或传递）闭包是A上的关系R′，使得 R′满足以下条件：</p>
<ol>
<li>R′是自反的（对称的或传递的）</li>
<li>R$\subseteq$R′</li>
<li>对A上任何包含R的自反（对称或传递）关系R″有R′$\subseteq$R″。</li>
</ol>
<p>一般将R的自反闭包记作r(R)，对称闭包记作s(R)，传递闭包记作t(R)。</p>
<blockquote>
<p>  闭包的构造方法</p>
</blockquote>
<p>设R为A上的关系，则有</p>
<ol>
<li>r(R)＝R∪R^0^</li>
<li>s(R)＝R∪R^-1^</li>
<li>t(R)＝R∪R^2^∪R^3^∪…</li>
</ol>
<details class="folding-tag" green><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3ca682ab3f51d911a253b.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3caf92ab3f51d911a8a4c.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3cb212ab3f51d911aa53e.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3cb372ab3f51d911ab37b.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p> 通过关系矩阵求闭包</p>
</blockquote>
<p>设关系R，r(R)，s(R)，t(R)的关系矩阵分别为M，M~r~，M~s~和M~t~，则<br>        Mr ＝ M＋E            对角线上的值都改为1<br>        Ms ＝ M＋M′            若aij＝1，则令aji＝1<br>        Mt ＝ M＋M^2^＋M^3^＋…        沃舍尔算法<br>其中E是和M同阶的单位矩阵，M′是M的转置矩阵。<br>注意在上述等式中矩阵的元素相加时使用逻辑加。</p>
<blockquote>
<p>  通过关系图求闭包</p>
</blockquote>
<p>设关系R，r(R)，s(R)，t(R)的关系图分别记为G，G~r~，G~s~，G~t~，则G~r~，G~s~，G~t~的顶点集与G的顶点集相等。<br>除了G的边以外，以下述方法添加新的边。</p>
<ol>
<li>考察G的每个顶点，如果没有环就加上一个环。最终得到的是G~r~。</li>
<li>考察G的每一条边，如果有一条x~i~到x~j~的单向边，i≠j，则在G中加一条边x~j~到x~i~的反方向边。最终得到G~s~。</li>
<li>考察G的每个顶点x~i~，找出从x~i~出发的所有2步，3步，…，n步长的路径（n为G中的顶点数）。设路径的终点为x~j1~, x~j2~, x~j3~, … x~jk~ 。如果没有从x~i~到 x~jl~(l=1,2,…,k)的边，就加上这条边。当检查完所有的顶点后就得到图G~t~。</li>
</ol>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3e4722ab3f51d91300ab8.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  闭包的主要性质</p>
</blockquote>
<ul>
<li>设R是非空集合A上的关系，则<ol>
<li>R是自反的当且仅当r(R)＝R。</li>
<li>R是对称的当且仅当s(R)＝R。</li>
<li>R是传递的当且仅当t(R)＝R。</li>
</ol>
</li>
<li>设R~1~和R~2~是非空集合A上的关系，且R~1~ $\subseteq$ R~2~，则<ol>
<li>r(R~1~) $\subseteq$ r(R~2~)</li>
<li>s(R~1~) $\subseteq$ s(R~2~)</li>
<li>t(R~1~) $\subseteq$ t(R~2~)</li>
</ol>
</li>
<li>若R是对称的，则R^n^也是对称的，其中n是任何正整数。</li>
<li>设R是非空集合A上的关系，<ol>
<li>若R是自反的，则s(R)与t(R)也是自反的。</li>
<li>若R是对称的，则r(R)与t(R)也是对称的。</li>
<li>若R是传递的，则r(R)是传递的。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>从这里可以看出，如果计算关系R的自反、对称、传递的闭包，为了不失去传递性，传递闭包运算应该放在对称闭包运算的后边，若令tsr(R)表示R的自反、对称、传递闭包，则tsr(R)=t(s(r(R)))</p>
</div>
</li>
</ol>
</li>
</ul>
<h3 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h3><blockquote>
<p>  等价关系</p>
</blockquote>
<p>设R为非空集合上的关系。如果R是自反的、对称的和传递的，则称R为A上的<span class='p cyan'>等价关系</span>(equivalent relation)。设R是一个等价关系，若<x，y>∈R，称x等价于y，记做x～y。</p>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <ol><li>平面上三角形集合中，三角形的相似关系。</li><li>人群中的同性关系。<br><img src="https://pic.imgdb.cn/item/61d3ead82ab3f51d9134eb4a.png" alt=""></li></ol>
              </div>
            </details>
<blockquote>
<p>  等价类</p>
</blockquote>
<p>设R为非空集合A上的等价关系，$\forall$x∈A，令[x]~R~={y|y∈A∧xRy}，称[x]~R~为x关于R的等价类，简称为x的等价类，简记为[x]或 $\bar x$ 。<br>x的等价类是A中所有与x等价的元素构成的集合。</p>
<p>例7.16中的等价类是：<br>[1]＝[4]＝[7]＝{1,4,7}<br>[2]＝[5]＝[8]＝{2,5,8}<br>[3]＝[6]＝{3,6}</p>
<blockquote>
<p>  等价类的性质</p>
</blockquote>
<p>设R是非空集合A上的等价关系，则</p>
<ol>
<li>$\forall$x∈A，[x]是A的非空子集。</li>
<li>$\forall$x,y∈A，如果xRy，则[x]＝[y]。</li>
<li>$\forall$x,y∈A，如果<x,y>∉R，则[x]与[y]不交。</li>
<li>∪{[x]|x∈A}＝A。</li>
</ol>
<details class="folding-tag" green><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3f1032ab3f51d9139ce4d.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3f10c2ab3f51d9139d534.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3f1152ab3f51d9139dbcf.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3f1222ab3f51d9139e5d7.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  商集</p>
</blockquote>
<p>设R为非空集合A上的等价关系，以R的所有等价类作为元素的集合称为A关于R的<span class='p cyan'>商集</span>(quotient set)，记做A/R，即A/R={[x]~R~|x∈A}</p>
<blockquote>
<p>  划分</p>
</blockquote>
<p>设A为非空集合，若A的子集族π(π$\subseteq$P(A)，是A的子集构成的集合) 满足下面的条件：</p>
<ol>
<li>$\emptyset$∉π</li>
<li>$\forall$x$\forall$y(x,y∈π∧x≠y→x$\cap$y＝$\emptyset$)</li>
<li>∪π=A<br>则称π是A的一个<span class='p cyan'>划分</span>(partitions)，称π中的元素为A的划分块。</li>
</ol>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3f36c2ab3f51d913bd579.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3f4792ab3f51d913ca832.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3f4842ab3f51d913cb281.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>商集就是A的一个划分，并且不同的商集将对应于不同的划分。</p>
</div>
<h3 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h3><blockquote>
<p>  偏序关系</p>
</blockquote>
<p>设R为非空集合A上的关系。如果R是自反的、反对称的和传递的，则称R为A上的<span class='p cyan'>偏序关系</span>，记作≤。设≤为偏序关系，如果<x,y>∈≤，则记作x≤y，读作“x小于或等于y”。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>这里的“小于或等于”不是指数的大小，而是在偏序关系中的顺序性。x“小于或等于”y的含义是：依照这个序，x排在y的前边或者x就是y。根据不同偏序的定义，对序有着不同的解释。</p>
</div>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <ol><li>集合A上的恒等关系I~A~</li><li>小于或等于关系</li><li>整除关系</li><li>包含关系</li></ol>
              </div>
            </details>
<blockquote>
<p>  可比</p>
</blockquote>
<p>设R为非空集合A上的偏序关系，定义</p>
<ol>
<li>$\forall$x,y∈A，x＜y $\Leftrightarrow$ x≤y∧x≠y。</li>
<li>$\forall$x,y∈A，x与y可比 $\Leftrightarrow$ x≤y∨y≤x。</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在具有偏序关系的集合A中任取两个元素x和y，可能有下述几种情况发生：x＜y(或y＜x)，x＝y，x与y不是可比的。例如A＝{1，2，3}，≤是A上的整除关系，则有1＜2，1＜3，1=1，2=2，3=3，2和3不可比。</p>
</div>
<blockquote>
<p>  全序关系</p>
</blockquote>
<p>设R为非空集合A上的偏序关系，如果$\forall$x,y∈A，x与y都是可比的，则称R为A上的<span class='p cyan'>全序关系</span>(或线序关系)。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>数集上的小于或等于关系是全序关系，因为任何两个数总是可比大小的。整除关系一般来说不是全序关系，如集合{1,2,3}上的整除关系就不是全序关系，因为2和3不可比。</p>
</div>
<blockquote>
<p>  偏序集</p>
</blockquote>
<p>集合A和A上的偏序关系≤一起叫做偏序集，记作<A,≤>。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>整数集合Z和数的小于或等于关系≤构成偏序集<Z,≤><br>集合A的幂集P(A)和包含关系R$\subseteq$构成偏序集<P(A),R$\subseteq$>。</p>
</div>
<blockquote>
<p>  覆盖</p>
</blockquote>
<p>设<A,≤>为偏序集。 $\forall$x,y∈A，如果 x＜y 且不存在 z∈A使得x＜z＜y，则称y<span class='p cyan'>覆盖</span>x。</p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>{1,2,4,6}集合上的整除关系，有2覆盖1，4和6都覆盖2。但4不覆盖1，因为有1＜2＜4。6也不覆盖4，因为4＜6不成立。</p>
</div>
<blockquote>
<p>  哈斯图</p>
</blockquote>
<p>利用偏序关系的自反性、反对称性和传递性所得到的偏序集合图，称为<span class='p cyan'>哈斯图</span>。<br>画偏序集<A，≤>的哈斯图的方法:</p>
<pre><code>1. 用小圆圈代表元素。
2. $\forall$x,y∈A，若x＜y，则将x画在y的下方。
3. 对于A中的两个不同元素x和y，如果y覆盖x，就用一条线段连接x和y。
</code></pre><details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d3fa902ab3f51d9142cd70.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d3fc822ab3f51d9144466d.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  偏序集中的特殊元素</p>
</blockquote>
<p>设<A，≤>为偏序集，B$\subseteq$A，y∈B。</p>
<ol>
<li>若$\forall$x(x∈B→y≤x)成立，则称y为B的<span class='p cyan'>最小元</span>。</li>
<li>若$\forall$x(x∈B→x≤y)成立，则称y为B的<span class='p cyan'>最大元</span>。</li>
<li>若$\forall$x(x∈B∧x≤y→x＝y)成立，则称y为B的<span class='p cyan'>极小元</span>。</li>
<li>若$\forall$x(x∈B∧y≤x→x＝y)成立，则称y为B的<span class='p cyan'>极大元</span>。</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>最小元是B中最小的元素，它与B中其它元素都可比。</li>
<li>极小元不一定与B中元素可比，只要没有比它小的元素，它就是极小元。</li>
<li>对于有穷集B，极小元一定存在，但最小元不一定存在。最小元如果存在，一定是唯一的。</li>
<li>极小元可能有多个，但不同的极小元之间是不可比的（无关系）。</li>
<li>如果B中只有一个极小元，则它一定是B的最小元。</li>
<li>哈斯图中，集合B的极小元是B中各元素中的最底层。</li>
<li>哈斯图中的孤立顶点既是极小元也是极大元。</li>
</ol>
</div>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d400312ab3f51d91477dfd.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d403082ab3f51d9149e302.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d403e82ab3f51d914ab68d.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  上界、下界</p>
</blockquote>
<p>设<A，≤>为偏序集，B$\subseteq$A，y∈A。</p>
<ol>
<li>若$\forall$x(x∈B→x≤y)成立，则称y为B的<span class='p cyan'>上界</span>。</li>
<li>若 $\forall$x(x∈B→y≤x)成立，则称y为B的<span class='p cyan'>下界</span>。</li>
<li>令C＝{y|y为B的上界}，则称C的最小元为B的<span class='p cyan'>最小上界或上确界</span>。</li>
<li>令D＝{y|y为B的下界}，则称D的最大元为B的<span class='p cyan'>最大下界或下确界</span>。</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>B的最小元一定是B的下界，同时也是B的最大下界。</li>
<li>B的最大元一定是B的上界，同时也是B的最小上界</li>
<li>B的下界不一定是B的最小元，因为它可能不是B中的元素。</li>
<li>B的上界也不一定是B的最大元。</li>
<li>B的上界、下界、最小上界、最大下界都可能不存在。如果存在，最小上界与最大下界是唯一的。</li>
</ol>
</div>
<details class="folding-tag" green><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d4057e2ab3f51d914bf8d4.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  偏序关系实例-调度问题</p>
</blockquote>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d406a12ab3f51d914ce23f.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d406b22ab3f51d914cf0ea.png" alt=""></p>
              </div>
            </details>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义和性质"><a href="#函数的定义和性质" class="headerlink" title="函数的定义和性质"></a>函数的定义和性质</h3><p>设F为二元关系，若$\forall$x∈dom F，都存在唯一的y∈ran F 使xFy成立，则称F为<span class='p cyan'>函数</span>(function)(或称作映射(mapping))。对于函数F，如果有 xFy，则记作y＝F(x)，并称y为F在x的值。</p>
<blockquote>
<p>  函数相等</p>
</blockquote>
<p>设 F,G 为函数，则 F＝G $\Leftrightarrow$ F$\subseteq$G∧G$\subseteq$F<br>由定义可知，两个函数F和G相等, 一定满足下面两个条件：</p>
<ol>
<li>dom F＝dom G</li>
<li>$\forall$ x∈dom F＝dom G，都有 F(x)＝G(x)</li>
</ol>
<blockquote>
<p>  从A到B的函数</p>
</blockquote>
<ul>
<li>设A,B为集合，如果 f 为函数，dom f＝A，ran f$subseteq$B，则称 f 为从A到B的函数，记作 f：A→B。</li>
</ul>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>f：N→N，f(x)＝2x是从N到N的函数，</li>
<li>g：N→N，g(x)＝2也是从N到N的函数。</li>
</ol>
</div>
<ul>
<li>所有从A到B的函数的集合记作B^A^，读作“B上A”，符号化表示为 B^A^＝{f | f：A→B} 。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>若|A|＝m，|B|＝n，且m,n&gt;0，则|B^A^|＝n^m^。</li>
<li>当A或B至少有一个集合是空集时：<ol>
<li>A＝$\emptyset$且B＝$\emptyset$，则B^A^＝$\emptyset$<sup>$\emptyset$</sup>＝{$\emptyset$}。</li>
<li>A＝$\emptyset$且B≠$\emptyset$，则B^A^＝B<sup>$\emptyset$</sup>＝{$\emptyset$}。</li>
<li>A≠$\emptyset$且B＝$\emptyset$，则B^A^＝$\emptyset$<sup>A</sup>＝$\emptyset$。</li>
</ol>
</li>
</ol>
</div>
</li>
</ul>
<blockquote>
<p>  函数的像和完全原像</p>
</blockquote>
<p>设函数f：A→B，A~1~$\subseteq$A，B~1~$\subseteq$B。</p>
<ul>
<li>令f(A~1~)＝{f(x)|x∈A~1~}，称 f(A~1~)为A~1~在f 下的<span class='p cyan'>像</span>(image)。特别地，当A~1~＝A时，称 f(A)为函数的像。</li>
<li>令f^-1^(B~1~)＝{x|x∈A∧f(x)∈B~1~}，称f~-1~(B~1~)为B~1~在 f 下的<span class='p cyan'>完全原像</span>(preimage) 。</li>
</ul>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>注意区别函数的值和像两个不同的概念。函数值f(x)∈B，而函数的像f(A~1~)$\subseteq$B。</p>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d4fa672ab3f51d91e56759.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  满射、单射、双射</p>
</blockquote>
<p>设f:A→B,</p>
<ol>
<li>若ran f＝B，则称f:A→B是<span class='p cyan'>满射</span>(surjection)的。</li>
<li>若$\forall$y∈ran f 都存在<span class='p cyan'>唯一</span>的x∈A使得f(x)＝y，则称 f:A→B是<span class='p cyan'>单射</span>(injection)的。</li>
<li>若f 既是满射又是单射的，则称f:A→B是<span class='p cyan'>双射</span>(bijection)的(一一映像(one-to-one mapping)) .</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>如果f:A→B是满射的，则对于任意的y∈B，都存在x∈A，使得f(x)＝y。</li>
<li>如果f:A→B是单射的，则对于x1、x2$\in$A且x1≠x2，一定有f(x1)≠f(x2)。换句话说，如果对于x1、x2A有f(x1)＝f(x2)，则一定有x1＝x2。</li>
</ul>
</div>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d4fc062ab3f51d91e6830a.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4fcae2ab3f51d91e6e91d.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4fd152ab3f51d91e72be3.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4fd242ab3f51d91e735fd.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4fdaf2ab3f51d91e79d41.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4ff2d2ab3f51d91e8a9d3.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d4ff3a2ab3f51d91e8b3db.png" alt=""></p>
              </div>
            </details>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><blockquote>
<p>  常函数</p>
</blockquote>
<p>设f：A→B，如果存在c∈B，使得对所有的x∈A都有f(x)＝c，则称f：A→B是<span class='p cyan'>常函数</span>。</p>
<blockquote>
<p>  恒等函数</p>
</blockquote>
<p>设f：A→B，对所有的x∈A都有I~A~ (x)＝x，称IA为A上的<span class='p cyan'>恒等函数</span>。</p>
<blockquote>
<p>  单调递增函数</p>
</blockquote>
<p>设<A,≤>， <B,≤>为偏序集，f：A→B，如果对任意的x1, x2∈A， x1＜x2，就有f(x1)≤ f(x2)，则称f为<span class='p cyan'>单调递增</span>的；</p>
<p>如果对任意的x1, x2∈A, x1＜x2, 就有f(x1)＜ f(x2), 则称f为严格单调递增的。</p>
<p>类似的也可以定义单调递减和严格单调递减的函数。</p>
<blockquote>
<p>  特征函数</p>
</blockquote>
<p>设A为集合，对于任意的A’$\subseteq$A，A’的<span class='p cyan'>特征函数</span>X~A’~ : A→{0,1}定义为</p>
<script type="math/tex; mode=display">x _ { A' }  ( a ) = \{ \begin{array}  { l   }  { 1 , } & { a
\in A ^ { \prime } } \\ { 0 , } & { a \in A - A ^ { \prime } } \end{array}</script><details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d53b032ab3f51d911b77dc.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  自然映射</p>
</blockquote>
<p>设R是A上的等价关系，令g：A→A/R , g(a)=[a]，$\forall$a∈A,称g是从A到商集A/R的<span class='p cyan'>自然映射</span>。</p>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d53c112ab3f51d911c6ec0.png" alt=""></p>
              </div>
            </details>
<h3 id="函数的复合与反函数"><a href="#函数的复合与反函数" class="headerlink" title="函数的复合与反函数"></a>函数的复合与反函数</h3><blockquote>
<p>  函数的复合</p>
</blockquote>
<p>函数的复合就是关系的右复合，一切和关系右复合有关的定理都适用于函数的复合。本节重点考虑在复合中特有的性质。</p>
<ol>
<li>设F, G是函数，则F$\circ$G 也是函数，且满足<ol>
<li>dom  (F$\circ$G)＝{x|x∈dom F∧F(x)∈dom G}</li>
<li>$\forall$x∈dom (F$\circ$G)，有F$\circ$G(x)＝G(F(x))<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d53f0c2ab3f51d911f32a4.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d53f1a2ab3f51d911f427d.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>推论：</p>
<ul>
<li>设F, G, H为函数，则(F$\circ$G)$\circ$H和F$\circ$(G$\circ$H)都是函数， 且(F$\circ$%G) $\circ$H=F$\circ$(G$\circ$H)</li>
<li>设f：A→B，g：B→C，则f$\circ$g：A→C，且$\forall$x∈A都有f$\circ$g(x)=g(f(x))</li>
</ul>
</div></li>
</ol>
</li>
<li>设  f：A→B，g：B→C。<ol>
<li>如果 f：A→B， g：B→C都是满射的， 则f$\circ$g：A→C也是满射的。</li>
<li>如果 f：A→B， g：B→C都是单射的， 则f$\circ$g：A→C也是单射的。</li>
<li>如果 f：A→B， g：B→C都是双射的， 则f$\circ$g：A→C也是双射的。<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>该定理说明函数的复合能够保持函数单射、满射、双射的性质。<br>该定理反过来不为真</p>
</div>
<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d540f02ab3f51d9120faea.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d540fa2ab3f51d9121040d.png" alt=""></p>
              </div>
            </details></li>
</ol>
</li>
<li>设 f：A$\rightarrow$B，则 f ＝ f $\circ$ I~B~ ＝ I~A~$\circ$f<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d544aa2ab3f51d9124cc0d.png" alt=""></p>
              </div>
            </details>
</li>
</ol>
<blockquote>
<p>  反函数</p>
</blockquote>
<ul>
<li><p>反函数存在的条件：设f：A→B是双射的，则f^-1^：B→A也是双射的。</p>
<details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d545232ab3f51d912587ef.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d545362ab3f51d9125a87d.png" alt=""></p>
              </div>
            </details>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>对于双射函数f：A→B，称f^-1^：B→A是它的<span class='p cyan'>反函数</span>。</p>
</div>
</li>
<li><p>反函数性质：设f：A→B是双射的， 则f^-1^ $\circ$ f = I~B~， f $\circ$ f^-1^ = I~A~</p>
  <details class="folding-tag" cyan><summary> 证明 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d545ef2ab3f51d9126a7c0.png" alt=""></p>
              </div>
            </details>
</li>
</ul>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>证明函数 f:A→B是满射的，基本方法是：任取y∈B，找到x∈A(x与y相关，可能是一个关于y的表达式)或者证明存在x∈A，使得f(x)＝y。<br>证明函数 f:A→B是单射的，基本方法是：假设A中存在x1和x2，使得 f(x1)＝f(x2)，利用已知条件或者相关的定理最终证明x1＝x2。<br>实数集合上函数性质的判断方法:</p>
<ol>
<li>对于实数集合上的函数，通常可以通过求导找到极值点。而有的极小值（或极大值）恰好是函数的最小值（或最大值），这样就可以求出函数的值域，从而判断函数是否为满射的。</li>
<li>如果函数存在极值，那么可以断定函数不是单射的，因为在极值点两侧可以找到不相等的x1和x2满足 f(x1)＝f(x2)。</li>
<li>证明函数不具有某种性质的一般方法就是给出反例。</li>
<li>为证明函数不是单射的，需要找到x1≠x2且f(x1)＝f(x2)。有时可能不容易找到具体的x1和x2，但是可以证明这样的x1和x2是存在的。</li>
<li>证明函数不是满射的一般方法就是找到 y∈B－ran f。</li>
</ol>
</div>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d549f22ab3f51d912c7bfe.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d54a722ab3f51d912d4062.png" alt=""></p>
              </div>
            </details>
<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="无向图及有向图"><a href="#无向图及有向图" class="headerlink" title="无向图及有向图"></a>无向图及有向图</h3><blockquote>
<p>  无序积与多重集合</p>
</blockquote>
<ol>
<li>设A，B为任意的两个集合，称<img no-lazy class="inline" src="https://pic.imgdb.cn/item/61d554462ab3f51d913d83c9.png" style="height:1.5em"/>为A与B的<span class='p cyan'>无序积</span>，记作A&amp;B。可将无序积中的无序对{a,b}记为(a,b)，并且允许a＝b。无论a,b是否相等，均有(a,b)＝(b,a)，因而A&amp;B＝B&amp;A。</li>
<li>元素可以重复出现的集合称为<span class='p cyan'>多重集合</span>或者多重集，某元素重复出现的次数称为该元素的<span class='p cyan'>重复度</span>。</li>
</ol>
<blockquote>
<p>  无向图和有向图</p>
</blockquote>
<ul>
<li>一个<span class='p cyan'>无向图</span>是一个有序的二元组<V，E>,记作G，其中<ol>
<li>V≠$\emptyset$称为<span class='p cyan'>顶点集</span>，其元素称为<span class='p cyan'>顶点</span>或结点。</li>
<li>E称为<span class='p cyan'>边集</span>，它是无序积V&amp;V的多重子集，其元素称为无向边，简称边。</li>
</ol>
</li>
<li>一个<span class='p cyan'>有向图</span>是一个有序的二元组<V，E>，记作D，其中<br>  （1）V≠$\emptyset$称为顶点集，其元素称为顶点或结点。<br>  （2）E为边集，它是笛卡儿积V×V的多重子集，其元素称为有向边，简称边。</li>
</ul>
<blockquote>
<p>  有向图</p>
</blockquote>
<ol>
<li>G表示无向图，但有时用G泛指图(无向的或有向的)。</li>
<li>D只能表示有向图。</li>
<li>V(G)，E(G)分别表示G的<span class='p cyan'>顶点集</span>和边集。</li>
<li>若|V(G)|＝n，则称G为<span class='p cyan'>n阶图</span>。</li>
<li>若|V(G)|与|E(G)|均为有限数，则称G为<span class='p cyan'>有限图</span>。</li>
<li>若边集E(G)＝$\emptyset$，则称G为<span class='p cyan'>零图</span>，此时，又若G为n阶图，则称G为<span class='p cyan'>n阶零图</span>，记作N~n~，特别地，称N~1~为<span class='p cyan'>平凡图</span>。</li>
<li>在图的定义中规定顶点集V为非空集，但在图的运算中可能产生顶点集为空集的运算结果，为此规定顶点集为空集的图为<span class='p cyan'>空图</span>，并将空图记为$\emptyset$。</li>
</ol>
<blockquote>
<p>  标定图与非标定图、基图</p>
</blockquote>
<ul>
<li>将图的集合定义转化成图形表示之后，常用e~k~表示无向边(v~i~,v~j~)（或有向边<v~i~,v~j~>），并称顶点或边用字母标定的图为<span class='p cyan'>标定图</span>，否则称为非标定图。</li>
<li>将有向图各有向边均改成无向边后的无向图称为原来图的<span class='p cyan'>基图</span>。</li>
</ul>
<blockquote>
<p>  关联与关联次数、环、孤立点</p>
</blockquote>
<ul>
<li>设G＝<V,E>为无向图，e~k~＝(v~i~,v~j~)∈E，<ul>
<li>称v~i~,v~j~为e~k~的<span class='p cyan'>端点</span>，e~k~与v~i~或e~k~与v~j~是彼此相<span class='p cyan'>关联</span>的。</li>
<li>若v~i~≠v~j~，则称e~k~与v~i~或e~k~与v~j~的<span class='p cyan'>关联次数</span>为1。</li>
<li>若v~i~＝v~j~，则称e~k~与v~i~的关联次数为2，并称e~k~为<span class='p cyan'>环</span>。</li>
<li>任意的v~l~∈V，若v~l~≠v~i~且v~l~≠v~j~，则称e~k~与v~l~的关联次数为0。</li>
</ul>
</li>
<li>设D＝<V,E>为有向图，e~k~＝<v~i~,v~j~>∈E，称v~i~,v~j~为e~k~的端点。若v~i~＝v~j~，则称ek为D中的环。</li>
<li>无论在无向图中还是在有向图中，无边关联的顶点均称为<span class='p cyan'>孤立点</span>。</li>
</ul>
<blockquote>
<p>  相邻与邻接</p>
</blockquote>
<ul>
<li>设无向图G＝<V，E>，v~i~，v~j~∈V，e~k~，e~l~∈E。<ul>
<li>若$\exists$e~t~∈E，使得e~t~＝(v~i~，v~j~)，则称v~i~与v~j~是相邻的。</li>
<li>若e~k~与e~l~至少有一个公共端点，则称e~k~与e~l~是相邻的。</li>
</ul>
</li>
<li>设有向图D＝<V，E>，v~i~，v~j~∈V，e~k~，e~l~∈E。<br>  若$\exists$e~t~∈E，使得e~t~＝<v~i~，v~j~>，则称v~i~为e~t~的<span class='p cyan'>始点</span>，v~j~为e~t~的<span class='p cyan'>终点</span>，并称v~i~邻接到v~j~，v~j~邻接于v~i~。<br>  若e~k~的终点为e~l~的始点，则称e~k~与e~l~相邻。</li>
</ul>
<blockquote>
<p>  邻域</p>
</blockquote>
<ul>
<li><p>设无向图G＝<V，E>，$\forall$ v∈V，<br>称{u|u∈V∧(u,v)∈E∧u≠v}为v的<span class='p cyan'>邻域</span>，记做N~G~(v)。<br>称N~G~(v)∪{v}为v的<span class='p cyan'>闭邻域</span>，记做$\bar N$~G~(v)。<br>称{e|e∈E∧e与v相关联}为v的<span class='p cyan'>关联集</span>，记做I~G~(v)。</p>
</li>
<li><p>设有向图D＝<V，E>，$\forall$v∈V，<br>称{u|u∈V∧<v,u>∈E∧u≠v}为v的<span class='p cyan'>后继元集</span>，记做Г+~D~(v)。<br>称{u|u∈V∧<u,v>∈E∧u≠v}为v的<span class='p cyan'>先驱元集</span>，记做Г-~D~(v)。<br>称Г+~D~(v)∪Г-~D~(v)为v的<span class='p cyan'>邻域</span>，记做N~D~(v)。<br>称N~D~(v)∪{v}为v的<span class='p cyan'>闭邻域</span>，记做$\bar N$~D~(v)。</p>
</li>
</ul>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d558d92ab3f51d9142a28f.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  简单图与多重图</p>
</blockquote>
<p>在无向图中，关联一对顶点的无向边如果多于1条，则称这些边为<span class='p cyan'>平行边</span>，平行边的条数称为<span class='p cyan'>重数</span>。<br>在有向图中，关联一对顶点的有向边如果多于1条，并且这些边的始点和终点相同(也就是它们的方向相同)，则称这些边为平行边。<br>含平行边的图称为<span class='p cyan'>多重图</span>。<br>既不含平行边也不含环的图称为<span class='p cyan'>简单图</span>。</p>
<blockquote>
<p>  顶点的度数</p>
</blockquote>
<p>设G＝<V,E>为一无向图，$\forall$v∈V，称v作为边的端点次数之和为v的<span class='p cyan'>度数</span>，简称为度，记做 d~G~(v)。在不发生混淆时，简记为d(v)。<br>设D＝<V，E>为有向图，$\forall$v∈V，</p>
<pre><code>* 称v作为边的始点次数之和为v的&#123;% span cyan, 出度 %&#125;，记做d^+^~D~(v)，简记作d^+^(v)。
* 称v作为边的终点次数之和为v的&#123;% span cyan, 入度 %&#125;，记做d^-^~D~(v)，简记作d^-^(v)。
* 称d^+^(v)+d^-^(v)为v的度数，记做d(v)。
</code></pre><blockquote>
<p>  图的度数</p>
</blockquote>
<p>在无向图G中，<br>    最大度    △(G)＝max{d(v)|v∈V(G)}<br>    最小度    δ(G)＝min{d(v)|v∈V(G)}<br>在有向图D中，<br>    最大出度    △^+^(D)＝max{d^+^(v)|v∈V(D)}<br>    最小出度    δ^+^(D)＝min{d^+^(v)|v∈V(D)}<br>    最大入度    △^-^(D)＝max{d^-^(v)|v∈V(D)}<br>    最小入度    δ^-^(D)＝min{d^-^(v)|v∈V(D)}<br>称度数为1的顶点为<span class='p cyan'>悬挂顶点</span>，与它关联的边称为<span class='p cyan'>悬挂边</span>。度为偶数(奇数)的顶点称为偶度(奇度)顶点。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>无向图：环提供2度<br>有向图：环提供出度1，提供入度1</p>
</div>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d5c16c2ab3f51d919aae19.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  握手定理</p>
</blockquote>
<ul>
<li>设G＝<V,E>为任意无向图，V＝{v~1~,v~2~,…,v~n~}，|E|＝m，则<script type="math/tex; mode=display">\sum _ { i = 1 } ^ { n } d ( v _ { i } ) = 2 m</script>  说明：任何无向图中，各顶点度数之和等于边数的两倍。</li>
<li>设D＝<V,E>为任意有向图，V＝{v~1~,v~2~,…,v~n~}，|E|＝m，则<script type="math/tex; mode=display">\sum _ { i = 1 } ^ { n } d ( v _ { i } ) = 2 m , 且 \sum _ { i = 1 } ^ { n } d ^ { + } ( v _ { i } ) = \sum _ { i = 1 } ^ { n } d ^ { - } ( v _ { i } ) = m</script></li>
<li>推论：任何图(无向的或有向的)中，奇度顶点的个数是偶数。</li>
</ul>
<details class="folding-tag" cyan><summary> 问题研究 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d5c2fd2ab3f51d919bb677.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  度数列</p>
</blockquote>
<ul>
<li>设G＝<V,E>为一个n阶无向图，V＝{v~1~,v~2~,…,v~n~}，称d(v~1~)，d(v~2~)，…，d(v~n~)为G的<span class='p cyan'>度数列</span>。</li>
<li>对于顶点标定的无向图，它的度数列是唯一的。</li>
<li>反之，对于给定的非负整数列d＝{d~1~,d~2~,…,d~n~}，若存在V＝{v~1~,v~2~,…,v~n~}为顶点集的n阶无向图G，使得d(v~i~)＝d~i~，则称d是<span class='p cyan'>可图化</span>的。</li>
<li>特别地，若所得图是简单图，则称d是可简单图化的。<br>类似地，设D＝<V,E>为一个n阶有向图，V＝{v~1~,v~2~,…,v~n~}，称d(v~1~)，d(v~2~)，…，d(v~n~)为D的度数列，另外称d^+^(v~1~)，d^+^(v~2~)，…，d^+^(v~n~)与d^-^(v~1~)，d^-^(v~2~)，…，d^-^(v~n~)分别为D的出度列和入度列。</li>
</ul>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d5c4d82ab3f51d919ce59a.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  可图化的充要条件</p>
</blockquote>
<p>设非负整数列d＝(d~1~，d~2~，…，d~n~)，则d是可图化的当且仅当</p>
<script type="math/tex; mode=display">\sum _ { i = 1 } ^ { n } d _ { i } = 0 ( m o d 2 )</script><details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d5c5cd2ab3f51d919d880e.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  可简单图化判定</p>
</blockquote>
<p>设G为任意n阶无向简单图，则△(G)≤n-1。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>证明：因为G既无平行边也无环，所以G中任何顶点v至多与其余的n-1个顶点均相邻，于是d(v)≤n-1，由于v的任意性，所以△(G)≤n-1。</p>
</div>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d5c7142ab3f51d919e6f56.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d5c76d2ab3f51d919eabc5.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  图的同构</p>
</blockquote>
<p>设G1＝<V~1~,E~1~>，G~2~＝<V~2~,E~2~>为两个无向图，若存在双射函数f：V~1~→V~2~，对于v~i~,v~j~∈V~1~，(v~i~,v~j~)∈E~1~当且仅当(f(v~i~),f(v~j~))∈E~2~，并且(v~i~,v~i~)与(f(v~i~),f(v~j~))的重数相同，<br>则称G1与G2是<span class='p cyan'>同构</span>的，记做G1≌G2。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>说明：</p>
<ol>
<li>类似地，可以定义两个有向图的同构。</li>
<li>图的同构关系看成全体图集合上的二元关系。</li>
<li>图的同构关系是等价关系。</li>
<li>在图同构的意义下，图的数学定义与图形表示是一一对应的。</li>
</ol>
</div>
<blockquote>
<p>  完全图</p>
</blockquote>
<ul>
<li>设G为n阶无向简单图，若G中每个顶点均与其余的n-1个顶点相邻，则称G为n阶无向<span class='p cyan'>完全图</span>，简称n阶完全图，记做K~n~(n≥1)。</li>
<li>设D为n阶有向简单图，若D中每个顶点都邻接到其余的n-1个顶点，又邻接于其余的n-1个顶点，则称D是n阶有向完全图。</li>
<li>设D为n阶有向简单图，若D的基图为n阶无向完全图Kn，则称D是n阶竞赛图。</li>
</ul>
<div class="note icon-padding simple"><i class="note-icon fas fa-thumbs-up"></i><p>n阶无向完全图的边数为：n(n-1)/2<br>n阶有向完全图的边数为：n(n-1)<br>n阶竞赛图的边数为：n(n-1)/2</p>
</div>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d654852ab3f51d91dfd9b2.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  正则图</p>
</blockquote>
<p>设G为n阶无向简单图，若v∈V(G)，均有d(v)＝k，则称G为<span class='p cyan'>k-正则图</span>。</p>
<details class="folding-tag" cyan><summary> 课后巩固 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d6552f2ab3f51d91e0530a.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  子图</p>
</blockquote>
<ul>
<li>设G＝<V,E>，G’＝<V',E'>为两个图(同为无向图或同为有向图)，若V’$\subseteq$V且E’ $\subseteq$ E，则称G’是G的<span class='p cyan'>子图</span>，G为G’的<span class='p cyan'>母图</span>，记作G’ $\subseteq$ G。</li>
<li>若V’$\subset$V或E’$\subset$E，则称G’为G的<span class='p cyan'>真子图</span>。</li>
<li>若V’＝V，则称G’为G的<span class='p cyan'>生成子图</span>。</li>
<li>设G＝<V,E>为一图，V1$\subset$V且V1≠$\emptyset$，称以V~1~为顶点集，以G中两个端点都在V~1~中的边组成边集E~1~的图为G的V~1~导出的子图，记作G[V~1~]。</li>
<li>设E~1~$\subset$E且E1≠$\emptyset$，称以E~1~为边集，以E~1~中边关联的顶点为顶点集V~1~的图为G的E~1~导出的子图，记作G[E~1~]。</li>
</ul>
<details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d657282ab3f51d91e1bc87.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d65eab2ab3f51d91e79cb1.png" alt=""><br><img src="https://pic.imgdb.cn/item/61d65ecf2ab3f51d91e7bc4b.png" alt=""></p>
              </div>
            </details>
<blockquote>
<p>  补图</p>
</blockquote>
<p>设G＝<V,E>为n阶无向简单图，以V为顶点集，以所有使G成为完全图K~n~的添加边组成的集合为边集的图，称为G的<span class='p cyan'>补图</span>，记作G。若图G≌G，则称为G是<span class='p cyan'>自补图</span>。<br><details class="folding-tag" cyan><summary> 举例 </summary>
              <div class='content'>
              <p><img src="https://pic.imgdb.cn/item/61d6614c2ab3f51d91e98fe5.png" alt=""></p>
              </div>
            </details></p>
<blockquote>
<p>  边的收缩与增加</p>
</blockquote>
<p>设G＝<V,E>为无向图。</p>
<ol>
<li>设e∈E，用G-e表示从G中去掉边e，称为删除e。设E’ $\subset$ E，用G-E’表示从G中删除E’中所有的边，称为删除E’。</li>
<li>设v∈V，用G-v表示从G中去掉v及所关联的一切边，称为删除顶点v。设V’ $\subset$ V，用G-V’表示从G中删除V’中所有顶点，称为删除V’。</li>
<li>设边e＝(u,v)∈E，用G\e表示从G中删除e后，将e的两个端点u,v用一个新的顶点w(或用u或v充当w)代替，使w关联除e外u,v关联的所有边，称为边e的收缩。</li>
<li>设u,v∈V(u,v可能相邻，也可能不相邻)，用G∪(u,v)(或G^+^(u,v))表示在u,v之间加一条边(u,v)，称为加新边。</li>
</ol>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在收缩边和加新边过程中可能产生环和平行边。</p>
</div>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jezer.top">Jezer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jezer.top/posts/3fb56f9d/">https://jezer.top/posts/3fb56f9d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jezer.top" target="_blank">Jezer's Blogs</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/61cc7a302ab3f51d9119b16a.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://pic.imgdb.cn/item/61c56c552ab3f51d91fd6986.jpg" target="_blank"><img class="post-qr-code-img" src="https://pic.imgdb.cn/item/61c56c552ab3f51d91fd6986.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://pic.imgdb.cn/item/61c56b492ab3f51d91fcebf2.jpg" target="_blank"><img class="post-qr-code-img" src="https://pic.imgdb.cn/item/61c56b492ab3f51d91fcebf2.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src="https://pic.imgdb.cn/item/62a09fb109475431296de403.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.3</div><div class="player-name">Jezer</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:23.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>23/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:6.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>6/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:10.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>10/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description">已知花意，未闻花名，<br>再见花时，泪落千溟。<br>已知花意，未闻其花，<br>已见其花，未闻花名。<br></div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Jezer05"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Jezer05" target="_blank" title="icon-GitHub"><i class="Github"></i></a><a class="social-icon" href="mailto:jezer05@qq.com" target="_blank" title="icon-icon__fasongyoujian"><i class="Email"></i></a><a class="social-icon" href="https://space.bilibili.com/451165086?spm_id_from=333.1007.0.0" target="_blank" title="icon-bilibili"><i class="Bilibili"></i></a><a class="social-icon" href="https://gitee.com/Jezer05" target="_blank" title="icon-gitee"><i class="Gitee"></i></a><a class="social-icon" href="https://www.cnblogs.com/Jezer" target="_blank" title="icon-cnblogs1"><i class="Cnblogs"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_55759494?spm=1000.2115.3001.5343" target="_blank" title="icon-csdn1"><i class="CSDN"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="toc-number">1.</span> <span class="toc-text">命题逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%8F%8A%E8%81%94%E7%BB%93%E8%AF%8D"><span class="toc-number">1.1.</span> <span class="toc-text">命题符号化及联结词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">命题公式及分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E6%BC%94%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">等值演算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E7%BB%93%E8%AF%8D%E5%85%A8%E5%8A%9F%E8%83%BD%E9%9B%86"><span class="toc-number">1.5.</span> <span class="toc-text">联结词全功能集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF"><span class="toc-number">1.6.</span> <span class="toc-text">组合电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%E7%90%86%E8%AE%BA"><span class="toc-number">1.7.</span> <span class="toc-text">推理理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91"><span class="toc-number">2.</span> <span class="toc-text">一阶逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">一阶逻辑基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F%E5%8F%8A%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">一阶逻辑合式公式及解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E7%AD%89%E5%80%BC%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">一阶逻辑等值式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%89%8D%E6%9D%9F%E8%8C%83%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">一阶逻辑前束范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86%E7%90%86%E8%AE%BA"><span class="toc-number">2.5.</span> <span class="toc-text">一阶逻辑推理理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">集合的基本概念和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">集合的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">集合的基本运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">集合恒等式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">二元关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E5%AF%B9%E4%B8%8E%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF"><span class="toc-number">4.1.</span> <span class="toc-text">有序对与笛卡尔积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB-1"><span class="toc-number">4.2.</span> <span class="toc-text">二元关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.3.</span> <span class="toc-text">二元关系的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.4.</span> <span class="toc-text">二元关系的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">4.5.</span> <span class="toc-text">二元关系的闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%88%92%E5%88%86"><span class="toc-number">4.6.</span> <span class="toc-text">等价关系与划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB"><span class="toc-number">4.7.</span> <span class="toc-text">偏序关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.</span> <span class="toc-text">函数的定义和性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E5%90%88%E4%B8%8E%E5%8F%8D%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">函数的复合与反函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.</span> <span class="toc-text">图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">6.1.</span> <span class="toc-text">无向图及有向图</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic.imgdb.cn/item/61cc7a302ab3f51d9119b16a.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Jezer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn();"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-2g6cx9mnb26a0cb8',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'twikoo-2g6cx9mnb26a0cb8',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer data-pjax src="/js/custom/wow_init.js"></script><script async data-pjax src="/js/custom/randombg.js"></script><script async src="/js/custom/diytitle.js"></script><script data-pjax defer src="/js/custom/fixed_comment.js"></script><script async src="//at.alicdn.com/t/font_3061941_9gurxjrwbmg.js"></script><div class="aplayer no-destroy" data-id="8289648289" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="//code.tidio.co/gs8taylk1pdyas7mfhyl5jcwv2jokglr.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/40a36fe6/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic.imgdb.cn/item/628b8367094754312911cd6e.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/40a36fe6/&quot;);" href="javascript:void(0);" alt="">SSM项目开发流程</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/40a36fe6/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6c92115f/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic.imgdb.cn/item/61c67a922ab3f51d916fe871.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6c92115f/&quot;);" href="javascript:void(0);" alt="">Spring</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6c92115f/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/da3e1361/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic.imgdb.cn/item/61c67f012ab3f51d9172068e.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/da3e1361/&quot;);" href="javascript:void(0);" alt="">Mybatis</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/da3e1361/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/99720b1c/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic.imgdb.cn/item/61c67f2a2ab3f51d917218d2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/99720b1c/&quot;);" href="javascript:void(0);" alt="">JavaWeb</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/99720b1c/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/787cbc62/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic.imgdb.cn/item/61c67d5e2ab3f51d917135f2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/787cbc62/&quot;);" href="javascript:void(0);" alt="">MySQL语法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/787cbc62/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>